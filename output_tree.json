{"id":1,"name":"오라클 함수","description":"오라클의 함수는 내장함수와 사용자 정의 함수로 나눌 수 있는데, 내장함수는 단일행 함수와 다중행 함수로 나눌 수 있습니다.\n함수의 입력 행 수에 따라 단일행 함수와 다중행 함수로 구분할 수 있습니다.","itemType":"C","parentId":0,"children":[{"id":8,"name":"단일행 함수(Single-Row Functions)","description":"SELECT, WHERE, ORDER BY, UPDATE SET 절에 사용 가능합니다.\n각 행들에 대해 개별적으로 작용하여 데이터 값들을 조작하고, 각각의 행에 대한 조작 결과를 반환합니다.\n여러 인자를 입력해도 단 하나의 결과만 반환합니다.\n함수의 인자로 상수, 변수, 표현식이 사용 가능하고, 하나의 인수를 가지는 경우도 있지만 여러개의 인수를 가질 수도 있습니다.\n특별한 경우가 아니면 함수의 인자로 함수를 사용하는 함수의 중첩이 가능합니다.","itemType":"C","parentId":1,"children":[{"id":24,"name":"문자 함수(Character Functions)","description":"문자 타입의 인자를 받아 데이터를 처리 및 조작하여 문자나 숫자 타입의 값을 반환하는 함수입니다.","itemType":"C","parentId":8,"children":[{"id":26,"name":"숫자를 반환하는 문자 함수(Character Functions Returning Number Values)","description":"문자 타입을 인자로 받아 숫자 타입을 반환합니다.","itemType":"C","parentId":24,"children":[{"id":38,"name":"INSTR","description":"INSTR(string, substring, position, occurrence) 형식으로 사용합니다.\nINSTR 함수는 문자열에서 부분 문자열을 검색합니다.\nstring은 검색 대상이 되는 문자열이고, substring은 검색할 부분 문자열입니다.\nposition은 검색을 시작할 위치 인덱스 값입니다. occurrence은 검색할 문자열의 발생 횟수를 나타냅니다.\n\nSELECT INSTR(\u0027CORPORATE FLOOR\u0027,\u0027OR\u0027, 3, 2) FROM DUAL은 주어진 문자열의 3번째 index부터 \u0027OR\u0027문자가 2번째로 나타나는 위치를 반환합니다.\n","itemType":"F","parentId":26,"examples":[{"fnId":38,"id":2,"query":"SELECT INSTR(\u0027CORPORATE FLOOR\u0027,\u0027OR\u0027, 3, 2) FROM DUAL;","exOrder":0}],"children":[]},{"id":39,"name":"LENGTH","description":"LENGTH(arg1)형식으로 사용합니다.\nLENGTH 함수는 문자열의 길이를 반환합니다.\nLENGTHB는 문자 대신 바이트를 사용합니다.\nSELECT LENGTH(\u0027CANDIDE\u0027) FROM DUAL 싱글 바이트 문자셋, \nSELECT LENGTHB (\u0027CANDIDE\u0027) FROM DUAL는 더블 바이트 문자셋의 예시입니다.","itemType":"F","parentId":26,"examples":[{"fnId":39,"id":2,"query":"SELECT LENGTH(\u0027CANDIDE\u0027) FROM DUAL;","exOrder":0},{"fnId":39,"id":3,"query":"SELECT LENGTHB (\u0027CANDIDE\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":40,"name":"REGEXP_INSTR","description":"REGEXP_INSTR(source_string, pattern, position, occurrence, return_option, match_parameter) 형식으로 사용합니다.\nREGEXP_INSTR 함수는 INSTR 함수의 기능을 확장하여 문자열에서 정규 표현식 패턴을 검색할 수 있게 해줍니다. 이 함수는 입력 문자셋에서 정의된 문자를 사용하여 문자열을 평가합니다.\nreturn_option 인자의 값에 따라 일치하는 부분 문자열의 시작 또는 끝 위치를 나타내는 정수를 반환합니다. 일치하는 항목이 없는 경우 함수는 0을 반환합니다.\n\nSELECT REGEXP_INSTR(\u0027500 Oracle Parkway, Redwood Shores, CA\u0027, \u0027[^ ]+\u0027, 1, 6) FROM DUAL은\n1번째 index부터 검색하여 공백으로 시작하지 않는 문자열이 6번째로 발견되는 곳의 위치값을 반환합니다.","itemType":"F","parentId":26,"examples":[{"fnId":40,"id":2,"query":"SELECT REGEXP_INSTR(\u0027500 Oracle Parkway, Redwood Shores, CA\u0027, \u0027[^ ]+\u0027, 1, 6) FROM DUAL;","exOrder":0}],"children":[]},{"id":37,"name":"ASCII","description":"ASCII(arg1) 형식으로 사용합니다.\nASCII 함수는 CHAR 타입 인자의 아스키 코드 값을 10진수로 반환합니다.","itemType":"F","parentId":26,"examples":[{"fnId":37,"id":2,"query":"SELECT ASCII(\u0027Q\u0027) FROM DUAL;","exOrder":0}],"children":[]}]},{"id":27,"name":"문자를 반환하는 문자 함수(Character Functions Returning Character Values)","description":"문자를 인자로 받아 문자값을 반환합니다. 반환값의 최대 길이는 데이터 타입에 따라 다릅니다.\n길이 한도를 초과할 경우 CHAR나 VARCHAR2 타입은 값을 잘라서 에러없이 반환하고, CLOB 타입은 에러를 발생시키고 값을 반환하지 않습니다.","itemType":"C","parentId":24,"children":[{"id":42,"name":"CHR","description":"CHR(n USING NCHAR_CS) 형식으로 사용합니다.\nCHR함수는 데이터베이스 문자 세트 또는 각국어 문자세트(NCHAR_CS를 지정시)인 안의 VARCHAR2 값으로 n과 동등한 2진수를 가지는 문자를 반환합니다.\n보통 아스키 코드를 문자로 변환해서 반환합니다.\n싱글 바이트 문자 세트의 경우, 만약 n\u003e256인 경우, 오라클 데이터베이스는 n mod(나머지) 256의 동일한 이진수를 반환합니다. 멀티 바이트 문자셋의 경우, 인수 n은 하나의 전체적 코드 포인트를 해결할 필요가 있습니다.\n유효하지 않은 코드 포인트는 검증되지 않고, 유효하지 않은 코드 포인트를 지정했을 경우의 결과는 예측이 불가능합니다.\n\n데이터베이스 문자셋이 WE8ISO8859P1로 정의되는 ASCII 기반 시스템에서\nSELECT CHR(67)||CHR(65)||CHR(84) FROM  DUAL; 쿼리가 실행되면 CAT을 반환합니다.\nWE8EBCDIC1047의 EBCDIC 기반 시스템에서 같은 결과를 반환하려면 아래와 같이 쿼리를 변환해야 합니다.\nSELECT CHR(195)||CHR(193)||CHR(227) FROM  DUAL;","itemType":"F","parentId":27,"examples":[{"fnId":42,"id":2,"query":"SELECT CHR(67)||CHR(65)||CHR(84) FROM  DUAL;","exOrder":0},{"fnId":42,"id":3,"query":"SELECT CHR(195)||CHR(193)||CHR(227) FROM  DUAL;","exOrder":0}],"children":[]},{"id":43,"name":"CONCAT","description":"CONCAT(str1, str2)형식으로 사용합니다.\nCONCAT  함수는 str1, str2를 연결한 결과를 반환합니다. 각 인자는 CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, NCLOB 중 어느 타입이든 가능하며 반환되는 문자열은 str1과 동일한 문자셋으로, 데이터 타입은 인자들의 데이터 타입에 따라 결정됩니다.\n","itemType":"F","parentId":27,"examples":[{"fnId":43,"id":2,"query":"SELECT CONCAT(CONCAT(last_name, \u0027\u0027\u0027s job category is \u0027), job_id) FROM employees WHERE employee_id \u003d 152;","exOrder":0}],"children":[]},{"id":44,"name":"INITCAP","description":"INITCAP(arg1)형식으로 사용합니다.\n각 단어의 첫 글자를 대문자로, 나머지 글자들을 소문자로 변환한 결과를 반환합니다. 단어는 공백이나 알파벳 이외의 문자로 구분됩니다.\n인자는 CHAR, VARCHAR2, NCHAR, NVARCHAR2 중 어떤 데이터 타입이든 될 수 있습니다. 반환되는 값의 데이터 타입은 인자의 타입과 동일합니다.\n이 함수는 CLOB 데이터를 직접 지원하지 않습니다. 그러나 암묵적인 데이터 변환을 통해 CLOB를 인자로 전달할 수 있습니다.\nSELECT INITCAP(\u0027the soap\u0027) FROM DUAL;  쿼리는 The Soap를 반환하는 예시입니다.","itemType":"F","parentId":27,"examples":[{"fnId":44,"id":2,"query":"SELECT INITCAP(\u0027the soap\u0027) FROM DUAL; ","exOrder":0}],"children":[]},{"id":45,"name":"LOWER","description":"LOWER(arg1) 형식으로 사용합니다.\nLOWER은 인자로 전달되는 문자열의 모든 글자를 소문자로 변환한 결과를 반환합니다. 인자는 CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, NCLOB 중 어떤 데이터 타입이든 될 수 있습니다. 반환되는 값의 데이터 타입은 인자의 타입과 동일합니다.","itemType":"F","parentId":27,"examples":[{"fnId":45,"id":2,"query":"SELECT LOWER(\u0027MR. SCOTT MCMILLAN\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":47,"name":"LTRIM","description":"LTRIM(str, set) 형식으로 사용합니다.\n두 번째 인자로 전달된 문자셋에 속한 문자를 첫 번째로 인자로 전달된 문자열의 왼쪽 끝에서부터 찾아서 제거합니다. 두 번째 인자를 지정하지 않으면 공백이 사용됩니다. 두 번째 문자셋에 속하지 않는 문자가 나올 때까지 반복됩니다.","itemType":"F","parentId":27,"examples":[{"fnId":47,"id":2,"query":"SELECT LTRIM(\u0027xyxXxyLAST WORD\u0027,\u0027xy\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":48,"name":"NLS_INITCAP","description":"NLS_INITCAP(str, nlsparam)형식으로 사용합니다.\nNLS_INITCAP 함수는 인자로 전달된 문자열에서 각 단어의 첫 글자를 대문자로, 나머지 글자를 소문자로 변환하여 반환합니다.\n단어는 영숫자가 아닌 문자 또는 공백으로 구분됩니다.","itemType":"F","parentId":27,"examples":[{"fnId":48,"id":2,"query":"SELECT NLS_INITCAP (\u0027ijsland\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":49,"name":"NLS_LOWER","description":"NLS_LOWER(str, nlsparam)형식으로 사용합니다.\nNLS_LOWER 함수는 str을 소문자로 반환합니다. str와 nlsparam은 CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB 또는 NCLOB와 같은 데이터 타입이 될 수 있습니다.\n반환되는 문자열은 동일한 문자셋으로 된 VARCHAR2 타입입니다.","itemType":"F","parentId":27,"examples":[{"fnId":49,"id":2,"query":"SELECT NLS_LOWER(\u0027CITTA\u0027\u0027\u0027, \u0027NLS_SORT \u003d XGerman\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":50,"name":"NLSSORT","description":"NLSSORT(str, nlsparam) 형식으로 사용합니다.\nNLSSORT함수는 char를 정렬하는데 사용되는 바이트 문자열을 반환합니다.\nstr와 nlsparam은  CHAR, VARCHAR2, NCHAR 또는 NVARCHAR2와 같은 데이터 유형이 될 수 있습니다.\n반환되는 문자열은 RAW 데이터 타입입니다.","itemType":"F","parentId":27,"examples":[{"fnId":50,"id":2,"query":"SELECT * FROM test ORDER BY NLSSORT(name, \u0027NLS_SORT \u003d XDanish\u0027);","exOrder":0}],"children":[]},{"id":54,"name":"REGEXP_REPLACE","description":"REGEXP_REPLACE(source_str, pattern, replace_str, position, occurrence, match_parameter) 형식으로 사용합니다.\nREPLACE 함수의 기능을 확장하여 문자열에서 정규 표현식 패턴을 검색할 수 있도록 합니다.\n기본적으로 함수는 source_string에서 정규 표현식 패턴의 모든 발생을 replace_string으로 대체한 문자열을 반환합니다. 반환되는 문자열은 source_string과 동일한 문자셋을 사용합니다.\n첫 번째 인자가 LOB가 아닌 경우 VARCHAR2를 반환하며, 첫 번째 인수가 LOB인 경우 CLOB를 반환합니다.","itemType":"F","parentId":27,"examples":[{"fnId":54,"id":2,"query":"SELECT REGEXP_REPLACE(phone_number, \u0027([[:digit:]]{3})\\.([[:digit:]]{3})\\.([[:digit:]]{4})\u0027, \u0027(\\1) \\2-\\3\u0027) FROM employees;","exOrder":0}],"children":[]},{"id":55,"name":"REGEXP_SUBSTR","description":"REGEXP_SUBSTR(source_string, pattern, position, occurrence, match_parameter) 형식으로 사용합니다.\nREGEXP_SUBSTR은 SUBSTR 함수의 기능을 확장하여 문자열에서 정규 표현식 패턴을 검색할 수 있도록 합니다.\nREGEXP_INSTR과 유사하지만, 부분 문자열의 위치를 반환하는 대신에 부분 문자열 자체를 반환합니다.\n이 함수는 매치된 문자열의 내용이 필요하지만 소스 문자열에서의 위치는 필요하지 않을 때 유용합니다.\n함수는 source_string과 동일한 문자셋으로 VARCHAR2 또는 CLOB 데이터로 문자열을 반환합니다.","itemType":"F","parentId":27,"examples":[{"fnId":55,"id":2,"query":"SELECT REGEXP_SUBSTR(\u0027500 Oracle Parkway, Redwood Shores, CA\u0027, \u0027,[^,]+,\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":53,"name":"NLS_UPPER","description":"NLS_UPPER(str, nplparam) 형식으로 사용합니다.\nstr의 모든 문자를 대문자로 변환하여 반환합니다.\nstr와 nlsparam은 CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB 또는 NCLOB와 같은 모든 데이터 타입이 될 수 있습니다. 반환되는 문자열은 VARCHAR2 데이터 타입이며, str와 동일한 문자셋을 사용합니다.\n\nSELECT NLS_UPPER (\u0027große\u0027) FROM DUAL; 쿼리는 GROßE를, SELECT NLS_UPPER (\u0027große\u0027, \u0027NLS_SORT \u003d XGerman\u0027) FROM DUAL; 쿼리는 GROSSE를 반환합니다.","itemType":"F","parentId":27,"examples":[{"fnId":53,"id":2,"query":"SELECT NLS_UPPER (\u0027große\u0027) FROM DUAL;","exOrder":0},{"fnId":53,"id":3,"query":"SELECT NLS_UPPER (\u0027große\u0027, \u0027NLS_SORT \u003d XGerman\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":56,"name":"REPLACE","description":"REPLACE(str, search_string, replacement_string) 형식으로 사용합니다.\nREPLACE함수는 str에서 search_string의 모든 발생을 replacement_string으로 대체한 결과를 반환합니다. 만약 replacement_string이 생략되거나 null이라면 search_string의 모든 발생이 제거됩니다. 만약 search_string이 null이라면 char이 반환됩니다.\nsearch_string, replacement_string, 그리고 str 모두 CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB 또는 NCLOB와 같은 어떤 데이터 타입이라도 될 수 있습니다. 반환되는 문자열은 str과 동일한 문자셋으로 되어 있습니다. 첫 번째 인자가 LOB가 아닌 경우 VARCHAR2를 반환하며, 첫 번째 인자가 LOB인 경우 CLOB를 반환합니다.","itemType":"F","parentId":27,"examples":[{"fnId":56,"id":2,"query":"SELECT REPLACE(\u0027JACK and JUE\u0027,\u0027J\u0027,\u0027BL\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":57,"name":"RPAD","description":"RPAD(exp1, n, exp2) 형식으로 사용합니다.\nRPAD 함수는 expr1을 expr2로 필요한 만큼 반복하여 길이가 n인 문자열로 오른쪽으로 패딩한 결과를 반환합니다. 이 함수는 쿼리의 출력을 형식화하는 데 유용합니다.\nexpr1과 expr2는 CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB 또는 NCLOB와 같은 어떤 데이터 유형이라도 될 수 있습니다. 반환되는 문자열은 VARCHAR2 데이터 유형이며, expr1과 동일한 문자 집합으로 구성됩니다. 인자 n은 NUMBER 정수 또는 NUMBER 정수로 암시적으로 변환 가능한 값이어야 합니다.\n만약 expr2를 지정하지 않으면 기본값으로 공백 하나가 사용됩니다. expr1의 길이가 n보다 긴 경우, 이 함수는 expr1에서 n에 맞는 부분만 반환합니다.\n인자 n은 반환 값이 터미널 화면에서 표시되는 전체 길이입니다. 대부분의 문자 집합에서 이는 반환 값의 문자 수와 동일합니다. 그러나 일부 멀티바이트 문자 집합에서는 문자열의 표시 길이가 문자 수와 다를 수 있습니다.","itemType":"F","parentId":27,"examples":[{"fnId":57,"id":2,"query":"SELECT last_name, RPAD(\u0027 \u0027, salary/1000/1, \u0027*\u0027) FROM employees WHERE department_id \u003d 80 ORDER BY last_name;","exOrder":0}],"children":[]},{"id":58,"name":"RTRIM","description":"RTRIM(char, set) 형식으로 사용합니다.\nRTRIM 함수는 char의 오른쪽 끝에 있는 set에 포함된 모든 문자를 제거합니다. 이 함수는 쿼리의 출력을 형식화하는 데 유용합니다.\n만약 set을 지정하지 않으면 기본값으로 공백 하나가 사용됩니다. char이 문자 리터럴인 경우, 해당 문자열을 작은 따옴표로 감싸야 합니다. RTRIM 함수는 LTRIM과 유사하게 동작합니다.\nchar와 set은 CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB 또는 NCLOB와 같은 어떤 데이터 유형이라도 될 수 있습니다. 반환되는 문자열은 VARCHAR2 데이터 유형이며, 문자셋은 char와 동일한 문자셋으로 구성됩니다.","itemType":"F","parentId":27,"examples":[{"fnId":58,"id":2,"query":"SELECT RTRIM(\u0027BROWNING: ./\u003d./\u003d./\u003d./\u003d./\u003d.\u003d\u0027,\u0027/\u003d.\u0027) \"RTRIM example\" FROM DUAL;","exOrder":0}],"children":[]},{"id":46,"name":"LPAD","description":"LPAD(exp1, n, exp2) 형식으로 사용합니다.\nLPAD 함수는 지정된 자리수 n으로부터 expr1을 채우고,왼편의 남은 공간에 expr1을 채웁니다. 이 함수는 쿼리의 출력 서식에 대하여 유용합니다.\n인수 expr1 과 인수 expr2의 데이터 형식은 CHAR,VARCHAR2,NCHAR,NVARCHAR2,CLOB,NCLOB 입니다. 반환되는 문자열은 VARCHAR2데이터형이고, 인수 expr1과 같은 문자입니다. 인수 n은 숫자 정수 또는 암묵적으로 정수로 변환가능한 값입니다.\n만약 expr2를 지정하지 않는다면, 기본값은 공백입니다. 만약 expr1이 n보다 크다면, 이 함수는 n에 적합한 expr1의 일부를 반환합니다.\n인자 n은 반환 값이 터미널 화면에 표시될 때의 총 길이입니다. 대부분의 문자 집합에서는 이것이 반환 값의 문자 수와도 같습니다. 그러나 몇몇 다중바이트 문자 집합에서는 문자열의 표시 길이가 문자 수와 다를 수 있습니다.","itemType":"F","parentId":27,"examples":[{"fnId":46,"id":2,"query":"SELECT LPAD(\u0027Page 1\u0027,15,\u0027*.\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":59,"name":"SOUNDEX","description":"SOUNDEX(char) 형식으로 사용합니다.\nSOUNDEX 함수는 char의 음성적인 표현을 포함하는 문자열을 반환합니다. 이 함수는 스펠링은 다르지만 영어에서는 비슷한 소리를 내는 단어를 비교할 수 있게 해줍니다.","itemType":"F","parentId":27,"examples":[{"fnId":59,"id":2,"query":"SELECT last_name, first_name FROM hr.employees WHERE SOUNDEX(last_name) \u003d SOUNDEX(\u0027SMYTHE\u0027);","exOrder":0}],"children":[]},{"id":60,"name":"SUBSTR","description":"SUBSTR(string, position, substring_length) 형식으로 사용합니다.\nSUBSTR 함수는 문자열에서 character position부터 substring_length 길이만큼의 부분 문자열을 반환합니다. SUBSTR 함수는 입력된 문자셋에 따라 문자 기준으로 길이를 계산합니다. SUBSTRB는 문자 대신 바이트를 사용하여 길이를 계산합니다. SUBSTRC는 유니코드 문자셋을 사용합니다. SUBSTR2는 UCS2 코드 포인트를 사용하고, SUBSTR4는 UCS4 코드 포인트를 사용합니다.","itemType":"F","parentId":27,"examples":[{"fnId":60,"id":2,"query":"SELECT SUBSTR(\u0027ABCDEFG\u0027,3,4) FROM DUAL;","exOrder":0},{"fnId":60,"id":3,"query":"SELECT SUBSTR(\u0027ABCDEFG\u0027,-5,4) FROM DUAL;","exOrder":0}],"children":[]},{"id":61,"name":"TRANSLATE","description":"TRANSLATE(expr, from_string, to_string) 형식으로 사용합니다.\nTRANSLATE 함수는 expr의 모든 문자열에서 from_string에 있는 각 문자를 to_string에 해당하는 문자로 대체한 결과를 반환합니다. from_string에 없는 문자는 대체되지 않습니다. expr이 문자열인 경우, 반드시 따옴표로 감싸야 합니다. from_string은 to_string보다 더 많은 문자를 포함할 수 있습니다. 이 경우, from_string의 끝에 있는 추가 문자는 to_string에 해당하는 문자가 없습니다. 이러한 추가 문자가 char에 나타나면 반환값에서 제거됩니다.","itemType":"F","parentId":27,"examples":[{"fnId":61,"id":2,"query":"SELECT TRANSLATE(\u0027SQL*Plus User\u0027\u0027s Guide\u0027, \u0027 */\u0027\u0027\u0027, \u0027___\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":62,"name":"TREAT","description":"TREAT(expr AS REF schema.type) 형식으로 사용합니다.\nTREAT 함수는 표현식의 선언된 타입을 변경합니다.\n이 함수를 사용하려면 타입에 대한 EXECUTE 개체 권한이 있어야 합니다.\n타입은 표현식의 선언된 타입의 일부 상위 타입 또는 하위 타입이어야 합니다. 만약 표현식의 가장 구체적인 타입이 타입(또는 타입의 하위 타입)인 경우, TREAT 함수는 표현식을 반환합니다. 표현식의 가장 구체적인 타입이 타입(또는 타입의 하위 타입)이 아닌 경우, TREAT 함수는 NULL을 반환합니다.\n표현식의 선언된 타입이 REF 타입인 경우에만 REF를 지정할 수 있습니다.\n표현식의 선언된 타입이 표현식의 소스 타입에 대한 REF인 경우, 타입은 표현식의 소스 타입의 일부 하위 타입 또는 상위 타입이어야 합니다. DEREF(expr)의 가장 구체적인 타입이 타입(또는 타입의 하위 타입)인 경우, TREAT 함수는 표현식을 반환합니다. DEREF(expr)의 가장 구체적인 타입이 타입(또는 타입의 하위 타입)이 아닌 경우, TREAT 함수는 NULL을 반환합니다.\n이 함수는 CLOB 데이터를 직접적으로 지원하지 않습니다. 그러나 CLOB는 암시적 데이터 변환을 통해 인수로 전달할 수 있습니다.","itemType":"F","parentId":27,"examples":[{"fnId":62,"id":2,"query":"SELECT name, TREAT(VALUE(p) AS employee_t).salary salary FROM persons p;","exOrder":0}],"children":[]},{"id":63,"name":"TRIM","description":"TRIM(LEADING/TRAILING/BOTH trim_character from arg) 형식으로 사용합니다.\nTRIM 함수는 문자열의 앞이나 뒤 (또는 둘 다)에서 문자를 제거하는 기능을 제공합니다. trim_character 또는 trim_source가 문자 리터럴인 경우에는 작은 따옴표로 감싸야 합니다.\nLEADING을 지정하면 Oracle Database는 trim_character와 일치하는 앞부분의 문자를 제거합니다.\nTRAILING을 지정하면 Oracle은 trim_character와 일치하는 뒷부분의 문자를 제거합니다.\nBOTH 또는 세 가지 중 아무 것도 지정하지 않은 경우 Oracle은 trim_character와 일치하는 앞뒤의 문자를 제거합니다.\ntrim_character를 지정하지 않은 경우 기본값은 공백입니다.\ntrim_source만 지정한 경우 Oracle은 앞뒤의 공백을 제거합니다.\n함수는 VARCHAR2 데이터 유형의 값을 반환합니다. 값의 최대 길이는 trim_source의 길이입니다.\ntrim_source 또는 trim_character 중 하나가 null인 경우 TRIM 함수는 null을 반환합니다.\ntrim_character와 trim_source는 모두 CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB 또는 NCLOB 데이터 유형일 수 있습니다. 반환된 문자열은 VARCHAR2 데이터 유형이며 trim_source와 동일한 문자셋입니다.","itemType":"F","parentId":27,"examples":[{"fnId":63,"id":2,"query":"SELECT employee_id, TO_CHAR(TRIM(LEADING 0 FROM hire_date)) FROM employees WHERE department_id \u003d 60;","exOrder":0}],"children":[]},{"id":64,"name":"UPPER","description":"UPPER(char) 형식으로 사용합니다.\nUPPER 함수는 데이터 타입이 char인 경우, 모든 문자를 대문자로 변환하여 char로 반환합니다. char는 CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB, NCLOB 등의 데이터 타입이 될 수 있습니다. 반환값은 입력된 데이터 타입과 동일한 데이터 타입을 가지게 됩니다.","itemType":"F","parentId":27,"examples":[{"fnId":64,"id":2,"query":"SELECT UPPER(\u0027Large\u0027) FROM DUAL;","exOrder":0}],"children":[]}]}]},{"id":25,"name":"숫자 함수(Numeric Functions)","description":"숫자 타입을 인자로 받아 숫자 타입을 반환합니다.\nNUMBER 타입을 반환하는 대부분의 경우 소수점 아래 38자리까지,\nCOS, COSH, EXP, LN, LOG, SIN, SINH, SQRT, TAN, TANH 초월 함수(transcendental functions)들은 소수점 아래 36자리까지,\nACOS, ASIN, ATAN, and ATAN2 초월 함수들은 소수점 아래 30자리까지 정확합니다.","itemType":"C","parentId":8,"children":[{"id":81,"name":"NANVL","description":"NANVL(m, n) 형식으로 사용합니다.\nNANVL 함수는 BINARY_FLOAT 또는 BINARY_DOUBLE 유형의 부동 소수점 숫자에만 유용합니다. 이 함수는 입력 값 m이 NaN(숫자가 아님)인 경우 대체 값 n을 반환하도록 Oracle 데이터베이스에 지시합니다. 만약 m이 NaN이 아닌 경우 Oracle은 m을 반환합니다. 이 함수는 NaN 값을 NULL로 매핑하는 데 유용합니다.\n이 함수는 숫자 데이터 유형이거나 숫자 데이터 유형으로 암묵적으로 변환될 수 있는 비숫자 데이터 유형을 인수로 사용합니다. Oracle은 가장 높은 숫자 우선순위를 가진 인수를 결정하고, 나머지 인수를 해당 데이터 타입으로 암묵적으로 변환한 후 해당 데이터 타입을 반환합니다.","itemType":"F","parentId":25,"examples":[{"fnId":81,"id":2,"query":"SELECT * FROM float_point_demo;","exOrder":0}],"children":[]},{"id":84,"name":"ROUND(number)","description":"ROUND(n, integer) 형식으로 사용합니다.\nROUND 함수는 소수점 오른쪽의 정수 위치로 n을 반올림하여 반환합니다. integer를 생략하면 n은 소수점 위치를 기준으로 반올림됩니다. integer 인수는 소수점 왼쪽의 자릿수를 반올림하기 위해 음수가 될 수 있습니다.\nn은 숫자 데이터 타입이거나 숫자 데이터 타입으로 암묵적으로 변환될 수 있는 비숫자 데이터 타입일 수 있습니다. integer 인수는 정수여야 합니다. integer를 생략하면 함수는 인수의 숫자 데이터 타입과 동일한 데이터 타입을 반환합니다. integer를 포함하면 함수는 NUMBER를 반환합니다.\nNUMBER 값의 경우, 값 n은 0에서 멀어지도록 반올림됩니다 (예: 양수 x.5의 경우 x+1로 반올림되고 음수 x.5의 경우 x-1로 반올림됩니다). BINARY_FLOAT 및 BINARY_DOUBLE 값의 경우, 함수는 가장 가까운 짝수 값으로 반올림합니다. ","itemType":"F","parentId":25,"examples":[{"fnId":84,"id":2,"query":"SELECT ROUND(15.193,1) \"Round\" FROM DUAL;","exOrder":0},{"fnId":84,"id":3,"query":"SELECT ROUND(1.5), ROUND(2.5) FROM DUAL;","exOrder":0},{"fnId":84,"id":4,"query":"SELECT ROUND(1.5f), ROUND(2.5f) FROM DUAL;","exOrder":0}],"children":[]},{"id":85,"name":"SIGN","description":"SIGN(n) 형식으로 사용합니다.\nSIGN 함수는 n의 부호를 반환합니다. 이 함수는 숫자 데이터 타입 또는 NUMBER로 암묵적으로 변환될 수 있는 비숫자 데이터 타입을 인수로 사용하고, NUMBER를 반환합니다.","itemType":"F","parentId":25,"examples":[{"fnId":85,"id":2,"query":"SELECT SIGN(-15) \"Sign\" FROM DUAL;","exOrder":0}],"children":[]},{"id":86,"name":"SIN","description":"SIN(n) 형식으로 사용합니다.\nSIN 함수는 n의 사인값을 반환합니다 (라디안으로 표현된 각도).\n이 함수는 숫자 데이터 타입 또는 숫자 데이터 타입으로 암묵적으로 변환될 수 있는 비숫자 데이터 타입을 인수로 사용합니다. 만약 인수가 BINARY_FLOAT인 경우, 함수는 BINARY_DOUBLE을 반환합니다. 그렇지 않은 경우, 함수는 인수와 동일한 숫자 데이터 타입을 반환합니다.","itemType":"F","parentId":25,"examples":[{"fnId":86,"id":2,"query":"SELECT SIN(30 * 3.14159265359/180) \"Sine of 30 degrees\" FROM DUAL;","exOrder":0}],"children":[]},{"id":87,"name":"SINH","description":"SINH(n) 형식으로 사용합니다.\nSINH 함수는 n의 쌍곡사인값을 반환합니다.\n이 함수는 숫자 데이터 타입이거나 숫자 데이터 타입으로 암묵적으로 변환될 수 있는 비숫자 데이터 타입을 인수로 사용합니다. 만약 인수가 BINARY_FLOAT인 경우, 함수는 BINARY_DOUBLE을 반환합니다. 그렇지 않은 경우, 함수는 인수와 동일한 숫자 데이터 타입을 반환합니다.","itemType":"F","parentId":25,"examples":[{"fnId":87,"id":2,"query":"SELECT SINH(1) \"Hyperbolic sine of 1\" FROM DUAL;","exOrder":0}],"children":[]},{"id":88,"name":"SQRT","description":"SQRT(n) 형식으로 사용합니다.\nSQRT 함수는 n의 제곱근을 반환합니다.\n이 함수는 숫자 데이터 타입이거나 숫자 데이터 타입으로 암묵적으로 변환될 수 있는 비숫자 데이터 타입을 인수로 사용합니다. 함수는 인수의 숫자 데이터 타입과 동일한 데이터 타입을 반환합니다.","itemType":"F","parentId":25,"examples":[{"fnId":88,"id":2,"query":"SELECT SQRT(26) \"Square root\" FROM DUAL;","exOrder":0}],"children":[]},{"id":89,"name":"TAN","description":"TAN(n) 형식으로 사용합니다.\nTAN 함수는 n의 탄젠트 값을 반환합니다 (각도는 라디안으로 표현됨).\n이 함수는 숫자 데이터 타입이거나 숫자 데이터 타입으로 암묵적으로 변환될 수 있는 비숫자 데이터 타입을 인수로 사용합니다. 인수가 BINARY_FLOAT인 경우 함수는 BINARY_DOUBLE을 반환합니다. 그렇지 않으면 함수는 인수와 동일한 숫자 데이터 타입을 반환합니다.","itemType":"F","parentId":25,"examples":[{"fnId":89,"id":2,"query":"SELECT TAN(135 * 3.14159265359/180) \"Tangent of 135 degrees\"  FROM DUAL;","exOrder":0}],"children":[]},{"id":90,"name":"TANH","description":"TANH(n) 형식으로 사용합니다.\nTANH 함수는 n의 하이퍼볼릭 탄젠트 값을 반환합니다.\n이 함수는 숫자 데이터 타입이거나 숫자 데이터 타입으로 암묵적으로 변환될 수 있는 비숫자 데이터 타입을 인수로 사용합니다. 인수가 BINARY_FLOAT인 경우 함수는 BINARY_DOUBLE을 반환합니다. 그렇지 않으면 함수는 인수와 동일한 숫자 데이터 타입을 반환합니다.","itemType":"F","parentId":25,"examples":[{"fnId":90,"id":2,"query":"SELECT TANH(.5) \"Hyperbolic tangent of .5\" FROM DUAL;","exOrder":0}],"children":[]},{"id":91,"name":"TRUNC(number)","description":"TRUNC(n, m) 형식으로 사용합니다.\nTRUNC 함수는 숫자 n을 m자리까지 절사하여 반환합니다. m이 생략된 경우 n은 소수점 이하 0자리까지 절사됩니다. m은 음수일 수 있어 소수점 왼쪽의 m자리를 절사(0으로 만들기)할 수 있습니다.\n이 함수는 숫자 데이터 타입이거나 숫자 데이터 타입으로 암묵적으로 변환될 수 있는 비숫자 데이터 타입을 인수로 사용합니다. m을 생략하면 함수는 인수와 동일한 숫자 데이터 타입을 반환합니다. m을 포함하면 함수는 NUMBER를 반환합니다.","itemType":"F","parentId":25,"examples":[{"fnId":91,"id":2,"query":"SELECT TRUNC(15.79,-1) \"Truncate\" FROM DUAL;","exOrder":0},{"fnId":91,"id":3,"query":"SELECT TRUNC(15.79,1) \"Truncate\" FROM DUAL;","exOrder":0}],"children":[]},{"id":92,"name":"WIDTH_BUCKET","description":"WIDTH_BUCKET(expr, min_value, max_value, num_buckets) 형식으로 사용합니다.\nWIDTH_BUCKET 함수는 동일한 크기를 갖는 구간으로 구성된 동일 너비의 히스토그램, 즉 등간격 히스토그램을 생성하는 데 사용됩니다. (이 함수를 NTILE 함수와 비교하면, NTILE 함수는 동일한 높이를 갖는 히스토그램을 생성합니다.) 이상적으로 각 버킷은 실수 직선의 폐-개 구간입니다. 예를 들어, 버킷은 10.00부터 19.999... 사이의 점수에 할당될 수 있으며, 이는 10이 구간에 포함되고 20은 제외된다는 것을 나타냅니다. 이는 때로 [10, 20)으로 표기됩니다.","itemType":"F","parentId":25,"examples":[{"fnId":92,"id":2,"query":"SELECT customer_id, cust_last_name, credit_limit, WIDTH_BUCKET(credit_limit, 100, 5000, 10) \"Credit Group\" FROM customers WHERE nls_territory \u003d \u0027SWITZERLAND\u0027 ORDER BY \"Credit Group\";","exOrder":0}],"children":[]},{"id":65,"name":"ABS","description":"ABS(n)\nABS 함수는 n의 절대값을 반환합니다.\n이 함수는 숫자 데이터 타입이나 숫자 데이터 타입으로 암시적으로 변환 가능한 비숫자 데이터 타입을 인수로 사용합니다. 함수는 인수의 숫자 데이터 타입과 동일한 데이터 타입을 반환합니다.","itemType":"F","parentId":25,"examples":[{"fnId":65,"id":2,"query":"SELECT ABS(-15) \"Absolute\" FROM DUAL;","exOrder":0}],"children":[]},{"id":66,"name":"ACOS","description":"ACOS(n) 형식으로 사용합니다.\nACOS 함수는 n의 아크 코사인 값을 반환합니다. 인수 n은 -1에서 1 사이의 범위여야 하며, 함수는 라디안 단위로 표현된 값으로 0에서 pi 사이의 범위를 반환합니다.\n이 함수는 모든 숫자 타입 데이터나 숫자 타입으로 암묵적으로 변환될 수 있는 비숫자 타입 데이터를 인수로 사용할 수 있습니다. 인수가 BINARY_FLOAT인 경우 함수는 BINARY_DOUBLE을 반환합니다. 그렇지 않은 경우 함수는 인수와 동일한 숫자 타입을 반환합니다.","itemType":"F","parentId":25,"examples":[{"fnId":66,"id":2,"query":"SELECT ACOS(.3)\"Arc_Cosine\" FROM DUAL;","exOrder":0}],"children":[]},{"id":69,"name":"ATAN2","description":"ATAN2(n, m)\nATAN2 함수는 n과 m의 아크 탄젠트 값을 반환합니다. 인수 n은 범위가 제한되지 않으며, 반환 값은 라디안 단위로 -pi에서 pi 사이의 범위에 위치하며, 이는 n과 m의 부호에 따라 달라집니다. ATAN2(n,m)은 ATAN(n/m)와 동일한 결과를 반환합니다.\n이 함수는 모든 숫자 타입 데이터나 숫자 타입으로 암묵적으로 변환될 수 있는 비숫자 타입 데이터를 인수로 사용할 수 있습니다. 만약 인수 중 하나가 BINARY_FLOAT 또는 BINARY_DOUBLE인 경우, 함수는 BINARY_DOUBLE을 반환합니다. 그렇지 않은 경우 함수는 NUMBER를 반환합니다.","itemType":"F","parentId":25,"examples":[{"fnId":69,"id":2,"query":"SELECT ATAN2(.3, .2) \"Arc_Tangent2\" FROM DUAL;","exOrder":0}],"children":[]},{"id":67,"name":"ASIN","description":"ASIN(n) 형식으로 사용합니다.\nASIN 함수는 n의 아크 사인 값을 반환합니다. 인수 n은 -1에서 1 사이의 범위여야 하며, 함수는 라디안 단위로 표현된 값으로 -pi/2에서 pi/2 사이의 범위를 반환합니다.\n이 함수는 모든 숫자 타입 데이터나 숫자 타입으로 암묵적으로 변환될 수 있는 비숫자 타입 데이터를 인수로 사용할 수 있습니다. 인수가 BINARY_FLOAT인 경우 함수는 BINARY_DOUBLE을 반환합니다. 그렇지 않은 경우 함수는 인수와 동일한 숫자 타입을 반환합니다.","itemType":"F","parentId":25,"examples":[{"fnId":67,"id":2,"query":"SELECT ASIN(.3) \"Arc_Sine\" FROM DUAL;","exOrder":0}],"children":[]},{"id":68,"name":"ATAN","description":"ATAN(n) 형식으로 사용합니다.\nATAN 함수는 n의 아크 탄젠트 값을 반환합니다. 인수 n은 범위가 제한되지 않으며, 함수는 라디안 단위로 표현된 -pi/2에서 pi/2 사이의 범위의 값을 반환합니다.\n이 함수는 모든 숫자 타입 데이터나 숫자 타입으로 암묵적으로 변환될 수 있는 비숫자 타입 데이터를 인수로 사용할 수 있습니다. 인수가 BINARY_FLOAT인 경우 함수는 BINARY_DOUBLE을 반환합니다. 그렇지 않은 경우 함수는 인수와 동일한 숫자 타입을 반환합니다.","itemType":"F","parentId":25,"examples":[{"fnId":68,"id":2,"query":"SELECT ATAN(.3) \"Arc_Tangent\" FROM DUAL;","exOrder":0}],"children":[]},{"id":73,"name":"CEIL","description":"CEIL(n)형식으로 사용합니다.\nCEIL 함수는 n보다 크거나 같은 가장 작은 정수를 반환합니다.\n이 함수는 숫자 데이터 타입이거나 숫자 데이터 타입으로 암묵적으로 변환될 수 있는 비숫자 데이터 타입을 인수로 받습니다. 함수는 인수의 숫자 데이터 타입과 동일한 데이터 타입을 반환합니다.","itemType":"F","parentId":25,"examples":[{"fnId":73,"id":2,"query":"SELECT CEIL(15.7) \"Ceiling\" FROM DUAL;","exOrder":0}],"children":[]},{"id":72,"name":"BITAND","description":"BITAND(expr1, expr2) 형식으로 사용합니다.\nBITAND 함수는 expr1과 expr2의 비트를 AND 연산하여 정수로 반환합니다. 이 때 expr1과 expr2는 음수가 아닌 정수로 해석될 수 있어야 합니다. 이 함수는 DECODE 함수와 함께 자주 사용되며, 아래 예시에서 설명되어 있습니다.\n두 인수 모두 숫자 데이터 타입이거나 NUMBER로 암묵적으로 변환될 수 있는 비숫자 데이터 타입일 수 있습니다. 이 함수는 NUMBER를 반환합니다.","itemType":"F","parentId":25,"examples":[{"fnId":72,"id":2,"query":"SELECT order_id, customer_id, DECODE(BITAND(order_status, 1), 1, \u0027Warehouse\u0027, \u0027PostOffice\u0027) Location, DECODE(BITAND(order_status, 2), 2, \u0027Ground\u0027, \u0027Air\u0027) Method, DECODE(BITAND(order_status, 4), 4, \u0027Insured\u0027, \u0027Certified\u0027) Receipt FROM orders WHERE order_status \u003c 8;","exOrder":0}],"children":[]},{"id":74,"name":"COS","description":"COS(n)형식으로 사용합니다.\nCOS 함수는 n(라디안으로 표현된 각도)의 코사인 값을 반환합니다.\n이 함수는 숫자 데이터 타입이거나 숫자 데이터 타입으로 암묵적으로 변환될 수 있는 비숫자 데이터 타입을 인수로 받습니다. 만약 인수가 BINARY_FLOAT인 경우, 함수는 BINARY_DOUBLE을 반환합니다. 그렇지 않은 경우 함수는 인수와 동일한 숫자 데이터 타입을 반환합니다.","itemType":"F","parentId":25,"examples":[{"fnId":74,"id":2,"query":"SELECT COS(180 * 3.14159265359/180) \"Cosine of 180 degrees\" FROM DUAL;","exOrder":0}],"children":[]},{"id":75,"name":"COSH","description":"COSH(n) 형식으로 사용합니다.\nCOSH 함수는 n의 쌍곡 코사인 값을 반환합니다.\n이 함수는 숫자 데이터 타입이거나 숫자 데이터 타입으로 암묵적으로 변환될 수 있는 비숫자 데이터 타입을 인수로 받습니다. 인수가 BINARY_FLOAT인 경우 함수는 BINARY_DOUBLE을 반환합니다. 그렇지 않은 경우 함수는 인수와 동일한 숫자 데이터 타입을 반환합니다.","itemType":"F","parentId":25,"examples":[{"fnId":75,"id":2,"query":"SELECT COSH(0) \"Hyperbolic cosine of 0\" FROM DUAL;","exOrder":0}],"children":[]},{"id":76,"name":"EXP","description":"EXP(n) 형식으로 사용합니다.\nEXP 함수는 e (자연 상수)를 n 제곱한 값을 반환합니다. 여기서 e는 약 2.71828183입니다. 이 함수는 인수와 동일한 유형의 값으로 반환됩니다.\n이 함수는 숫자 데이터 타입이거나 숫자 데이터 타입으로 암묵적으로 변환될 수 있는 비숫자 데이터 타입을 인수로 받습니다. 인수가 BINARY_FLOAT인 경우 함수는 BINARY_DOUBLE을 반환합니다. 그렇지 않은 경우 함수는 인수와 동일한 숫자 데이터 타입을 반환합니다.","itemType":"F","parentId":25,"examples":[{"fnId":76,"id":2,"query":"SELECT EXP(4) \"e to the 4th power\" FROM DUAL;","exOrder":0}],"children":[]},{"id":77,"name":"FLOOR","description":"FLOOR(n) 형식으로 사용합니다.\nFLOOR 함수는 n 이하이면서 가장 큰 정수를 반환합니다.\n이 함수는 숫자 데이터 타입이거나 숫자 데이터 타입으로 암묵적으로 변환될 수 있는 비숫자 데이터 타입을 인수로 받습니다. 함수는 인수의 숫자 데이터 타입과 동일한 데이터 타입을 반환합니다.","itemType":"F","parentId":25,"examples":[{"fnId":77,"id":2,"query":"SELECT FLOOR(15.7) \"Floor\" FROM DUAL;","exOrder":0}],"children":[]},{"id":78,"name":"LN","description":"LN(n) 형식으로 사용합니다.\nLN 함수는 n이 0보다 큰 경우에 대해 자연 로그 값을 반환합니다.\n이 함수는 숫자 데이터 유형이거나 숫자 데이터 유형으로 암묵적으로 변환될 수 있는 비숫자 데이터 유형을 인수로 사용합니다. 인수가 BINARY_FLOAT인 경우 함수는 BINARY_DOUBLE을 반환합니다. 그렇지 않은 경우 함수는 인수와 동일한 숫자 데이터 유형을 반환합니다.","itemType":"F","parentId":25,"examples":[{"fnId":78,"id":2,"query":"SELECT LN(95) \"Natural log of 95\" FROM DUAL;","exOrder":0}],"children":[]},{"id":79,"name":"LOG","description":"LOG(n, m) 형식으로 사용합니다.\nLOG 함수는 n의 밑이 m인 로그 값을 반환합니다. 밑 m은 0 또는 1이 아닌 양의 값이 될 수 있으며, n은 양의 값이 될 수 있습니다.\n이 함수는 숫자 데이터 유형이거나 숫자 데이터 유형으로 암묵적으로 변환될 수 있는 비숫자 데이터 유형을 인수로 사용합니다. 인수 중 하나가 BINARY_FLOAT 또는 BINARY_DOUBLE인 경우 함수는 BINARY_DOUBLE을 반환합니다. 그렇지 않은 경우 함수는 NUMBER를 반환합니다.","itemType":"F","parentId":25,"examples":[{"fnId":79,"id":2,"query":"SELECT LOG(10,100) \"Log base 10 of 100\" FROM DUAL;","exOrder":0}],"children":[]},{"id":80,"name":"MOD","description":"MOD(m, n) 형식으로 사용합니다.\nMOD 함수는 m을 n으로 나눈 나머지를 반환합니다. n이 0인 경우 m을 반환합니다.\n이 함수는 숫자 데이터 유형이거나 숫자 데이터 유형으로 암묵적으로 변환될 수 있는 비숫자 데이터 유형을 인수로 사용합니다. Oracle은 가장 높은 숫자 우선순위를 가진 인수를 결정하고, 나머지 인수를 해당 데이터 타입으로 암묵적으로 변환한 후 해당 데이터 타입을 반환합니다.","itemType":"F","parentId":25,"examples":[{"fnId":80,"id":2,"query":"SELECT MOD(11,4) \"Modulus\" FROM DUAL;","exOrder":0}],"children":[]},{"id":82,"name":"POWER","description":"POWER(m, n) 형식으로 사용합니다.\nPOWER 함수는 m을 n번 곱한 값을 반환합니다. 기저값 m과 지수 n은 어떤 숫자든 될 수 있지만, m이 음수인 경우 n은 정수여야 합니다.\n이 함수는 숫자 데이터 유형이거나 숫자 데이터 유형으로 암묵적으로 변환될 수 있는 비숫자 데이터 유형을 인수로 사용합니다. 만약 인수 중 하나가 BINARY_FLOAT 또는 BINARY_DOUBLE인 경우, 함수는 BINARY_DOUBLE을 반환합니다. 그렇지 않으면 NUMBER를 반환합니다.","itemType":"F","parentId":25,"examples":[{"fnId":82,"id":2,"query":"SELECT POWER(3,2) \"Raised\" FROM DUAL;","exOrder":0}],"children":[]},{"id":83,"name":"REMAINDER","description":"REMAINDER(m, n) 형식으로 사용합니다.\nREMAINDER 함수는 m을 n으로 나눈 나머지를 반환합니다.\n이 함수는 숫자 데이터 유형이거나 숫자 데이터 유형으로 암묵적으로 변환될 수 있는 비숫자 데이터 유형을 인수로 사용합니다. Oracle은 가장 높은 숫자 우선순위를 가진 인수를 결정하고, 나머지 인수를 해당 데이터 타입으로 암묵적으로 변환한 후 해당 데이터 타입을 반환합니다.\nMOD 함수는 REMAINDER와 유사하지만, MOD는 FLOOR을 사용하고 REMAINDER는 ROUND를 사용하여 계산합니다.","itemType":"F","parentId":25,"examples":[{"fnId":83,"id":2,"query":"SELECT bin_float, bin_double, REMAINDER(bin_float, bin_double) FROM float_point_demo;","exOrder":0}],"children":[]}]},{"id":28,"name":"날짜 함수(Datetime Functions)","description":"날짜 함수들은 DATE, TIMESTAMP, INERVAL 타입을 인자로 받아 동작합니다.\n오라클 DATE 타입을 위해 설계된 일부 날짜 및 시간 함수로는 ADD_MONTHS, CURRENT_DATE, LAST_DAY, NEW_TIME 및 NEXT_DAY가 있고,\n이 함수들의 인자로 TIMESTAMP 타입을 제공하면 내부적으로 DATE 타입으로 변환하고, DATE 타입을 반환합니다.\n예외는 NUMBER 타입을 반환하는 MONTHS_BETWEEN 함수와 TIMESTAMP 또는 INTERVAL 값이 전혀 허용되지 않는 ROUND 및 TRUNC 함수입니다.","itemType":"C","parentId":8,"children":[{"id":93,"name":"ADD_MONTHS","description":"ADD_MONTHS(date, integer) 형식으로 사용합니다.\nADD_MONTHS 함수는 날짜 date에 정수형 월을 더한 결과를 반환합니다. date 인수는 날짜 및 시간 값이거나 DATE로 암시적으로 변환될 수 있는 값이 될 수 있습니다. 정수형 인수는 정수이거나 정수로 암시적으로 변환될 수 있는 값이 될 수 있습니다. 반환 타입은 date의 데이터 타입과 관계없이 항상 DATE입니다. 만약 date가 해당 월의 마지막 날이거나 결과 월이 date의 일 구성 요소보다 적은 날을 가지는 경우, 결과는 결과 월의 마지막 날이 됩니다. 그렇지 않으면 결과는 date와 동일한 일 구성 요소를 가집니다.","itemType":"F","parentId":28,"examples":[{"fnId":93,"id":2,"query":"SELECT TO_CHAR(ADD_MONTHS(hire_date,1), \u0027DD-MON-YYYY\u0027) \"Next month\" FROM employees WHERE last_name \u003d \u0027Baer\u0027;","exOrder":0}],"children":[]},{"id":94,"name":"CURRENT_DATE","description":"CURRENT_DATE 함수는 세션 시간대에서 현재 날짜를 Gregorian 달력의 DATE 데이터 타입으로 반환합니다.","itemType":"F","parentId":28,"examples":[{"fnId":94,"id":2,"exOrder":0}],"children":[]},{"id":95,"name":"CURRENT_TIMESTAMP","description":"CURRENT_TIMESTAMP(precision) 형식으로 사용합니다.\nCURRENT_TIMESTAMP 함수는 세션 시간대에서 현재 날짜와 시간을 TIMESTAMP WITH TIME ZONE 데이터 타입의 값으로 반환합니다. 시간대 오프셋은 SQL 세션의 현재 로컬 시간을 반영합니다. 정밀도를 생략하면 기본값은 6입니다. 이 함수와 LOCALTIMESTAMP 함수의 차이점은 CURRENT_TIMESTAMP가 TIMESTAMP WITH TIME ZONE 값을 반환하는 반면 LOCALTIMESTAMP는 TIMESTAMP 값을 반환한다는 것입니다.\n선택적 인수인 정밀도는 반환되는 시간 값의 소수 초 정밀도를 지정합니다.","itemType":"F","parentId":28,"examples":[{"fnId":95,"id":2,"exOrder":0}],"children":[]},{"id":96,"name":"DBTIMEZONE","description":"DBTIMEZONE 함수는 데이터베이스의 시간대 값을 반환합니다. 반환되는 데이터 타입은 시간대 오프셋(\u0027[+|-]TZH:TZM\u0027 형식의 문자열 타입) 또는 시간대 지역 이름입니다. 이는 사용자가 가장 최근의 CREATE DATABASE 또는 ALTER DATABASE 문에서 데이터베이스 시간대 값을 어떻게 지정했는지에 따라 달라집니다.","itemType":"F","parentId":28,"examples":[{"fnId":96,"id":2,"query":"SELECT DBTIMEZONE FROM DUAL;","exOrder":0}],"children":[]},{"id":97,"name":"EXTRACT(datetime)","description":"EXTRACT 함수는 datetime 또는 interval 값 표현식에서 지정된 datetime 필드의 값을 추출하여 반환합니다. TIMEZONE_REGION 또는 TIMEZONE_ABBR(약어)를 추출하는 경우, 반환되는 값은 해당 시간대 이름 또는 약어를 포함하는 문자열입니다. 다른 값을 추출하는 경우, 반환되는 값은 그레고리안 달력에 기반한 값입니다. 시간대 값을 포함하는 datetime에서 추출하는 경우, 반환되는 값은 UTC 시간대로 표시됩니다. ","itemType":"F","parentId":28,"examples":[{"fnId":97,"id":2,"query":"SELECT last_name, employee_id, hire_date FROM employees WHERE EXTRACT(YEAR FROM TO_DATE(hire_date, \u0027DD-MON-RR\u0027)) \u003e 1998 ORDER BY hire_date;","exOrder":0}],"children":[]},{"id":98,"name":"FROM_TZ","description":"FROM_TZ(timestamp_value, time_zone_value) 형식으로 사용합니다.\nFROM_TZ 함수는 타임스탬프 값과 시간대를 TIMESTAMP WITH TIME ZONE 값으로 변환합니다. time_zone_value는 \u0027TZH:TZM\u0027 형식의 문자열이거나 TZR과 선택적인 TZD 형식의 문자열을 반환하는 문자 표현식입니다.","itemType":"F","parentId":28,"examples":[{"fnId":98,"id":2,"query":"SELECT FROM_TZ(TIMESTAMP \u00272000-03-28 08:00:00\u0027, \u00273:00\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":100,"name":"LOCALTIMESTAMP","description":"LOCALTIMESTAMP(timestamp_precision) 형식으로 사용합니다.\nLOCALTIMESTAMP 함수는 세션의 시간대에 따라 현재 날짜와 시간을 TIMESTAMP 데이터 타입으로 반환합니다. 이 함수와 CURRENT_TIMESTAMP 함수의 차이점은 LOCALTIMESTAMP가 TIMESTAMP 값을 반환하는 반면, CURRENT_TIMESTAMP는 TIMESTAMP WITH TIME ZONE 값을 반환한다는 것입니다.\n옵션인 timestamp_precision은 반환되는 시간 값의 소수점 이하 자릿수 정밀도를 지정합니다.","itemType":"F","parentId":28,"examples":[{"fnId":100,"id":2,"exOrder":0}],"children":[]},{"id":101,"name":"MONTHS_BETWEEN","description":"MONTHS_BETWEEN(date1, date2) 형식으로 사용합니다.\nMONTHS_BETWEEN 함수는 날짜 date1과 date2 사이의 개월 수를 반환합니다. date1이 date2보다 늦은 경우 결과는 양수입니다. date1이 date2보다 이른 경우 결과는 음수입니다. 만약 date1과 date2가 같은 월의 같은 날이거나 둘 다 해당 월의 마지막 날인 경우, 결과는 항상 정수입니다. 그렇지 않은 경우 Oracle Database는 31일을 기준으로 결과의 소수 부분을 계산하며, date1과 date2의 시간 구성의 차이를 고려합니다.","itemType":"F","parentId":28,"examples":[{"fnId":101,"id":2,"query":"SELECT MONTHS_BETWEEN (TO_DATE(\u002702-02-1995\u0027,\u0027MM-DD-YYYY\u0027), TO_DATE(\u002701-01-1995\u0027,\u0027MM-DD-YYYY\u0027) ) \"Months\" FROM DUAL;","exOrder":0}],"children":[]},{"id":102,"name":"NEW_TIME","description":"NEW_TIME(date, timezone1, timezone2) 형식으로 사용합니다.\nNEW_TIME 함수는 날짜와 시간이 timezone1 시간대에 있을 때, timezone2 시간대에서의 날짜와 시간을 반환합니다. 이 함수를 사용하기 전에 NLS_DATE_FORMAT 매개변수를 설정하여 24시간 형식으로 표시해야 합니다. 반환되는 데이터 타입은 항상 DATE입니다. date의 데이터 타입과 관계없이 항상 DATE로 반환됩니다.","itemType":"F","parentId":28,"examples":[{"fnId":102,"id":2,"query":"SELECT NEW_TIME(TO_DATE(\u002711-10-99 01:23:45\u0027, \u0027MM-DD-YY HH24:MI:SS\u0027),\u0027AST\u0027, \u0027PST\u0027) \"New Date and Time\" FROM DUAL;","exOrder":0}],"children":[]},{"id":103,"name":"NEXT_DAY","description":"NEXT_DAY(date, char) 형식으로 사용합니다.\nNEXT_DAY 함수는 date 이후에 char로 지정된 첫 번째 평일의 날짜를 반환합니다. 반환되는 데이터 타입은 항상 DATE입니다. date의 데이터 타입과 관계없이 항상 DATE로 반환됩니다. 매개변수 char는 세션의 날짜 언어에서 요일로 지정된 값이어야 합니다. 요일은 전체 이름 또는 약어로 지정할 수 있으며, 최소한 약어 버전의 문자 수와 일치해야 합니다. 유효한 약어 다음에 바로 오는 문자는 무시됩니다. 반환값은 인수 date와 동일한 시간, 분 및 초 구성 요소를 가지게 됩니다.","itemType":"F","parentId":28,"examples":[{"fnId":103,"id":2,"query":"SELECT NEXT_DAY(\u002702-FEB-2001\u0027,\u0027TUESDAY\u0027) \"NEXT DAY\" FROM DUAL;","exOrder":0}],"children":[]},{"id":104,"name":"NUMTODSINTERVAL","description":"NUMTODSINTERVAL(n, interval_unit) 형식으로 사용합니다.\nNUMTODSINTERVAL 함수는 n을 INTERVAL DAY TO SECOND 리터럴로 변환합니다. 매개변수 n은 NUMBER 값이거나 NUMBER 값으로 암시적으로 변환될 수 있는 표현식일 수 있습니다. 매개변수 interval_unit은 CHAR, VARCHAR2, NCHAR 또는 NVARCHAR2 데이터 타입일 수 있습니다. interval_unit에 대한 값은 n의 단위를 지정하며 다음 문자열 값 중 하나로 해석되어야 합니다:","itemType":"F","parentId":28,"examples":[{"fnId":104,"id":2,"query":"SELECT manager_id, last_name, hire_date, COUNT(*) OVER (PARTITION BY manager_id ORDER BY hire_date RANGE NUMTODSINTERVAL(100, \u0027day\u0027) PRECEDING) AS t_count FROM employees;","exOrder":0}],"children":[]},{"id":105,"name":"NUMTOYMINTERVAL","description":"NUMTOYMINTERVAL(n, interval_unit) 형식으로 사용합니다.\nNUMTOYMINTERVAL 함수는 숫자 n을 INTERVAL YEAR TO MONTH 리터럴로 변환합니다. 매개변수 n은 NUMBER 값이거나 NUMBER 값으로 암시적으로 변환될 수 있는 표현식일 수 있습니다. 매개변수 interval_unit은 CHAR, VARCHAR2, NCHAR 또는 NVARCHAR2 데이터 타입일 수 있습니다. interval_unit에 대한 값은 n의 단위를 지정하며 다음 문자열 값 중 하나로 해석되어야 합니다:","itemType":"F","parentId":28,"examples":[{"fnId":105,"id":2,"query":"SELECT last_name, hire_date, salary, SUM(salary) OVER (ORDER BY hire_date RANGE NUMTOYMINTERVAL(1,\u0027year\u0027) PRECEDING) AS t_sal FROM employees;","exOrder":0}],"children":[]},{"id":107,"name":"SESSIONTIMEZONE","description":"SESSIONTIMEZONE 함수는 현재 세션의 시간대를 반환합니다. 반환되는 값은 시간대 오프셋(형식이 \u0027[+|]TZH:TZM\u0027인 문자열 타입) 또는 시간대 지역 이름일 수 있으며, 가장 최근의 ALTER SESSION 문에서 사용자가 세션 시간대 값을 어떻게 지정했는지에 따라 달라집니다.","itemType":"F","parentId":28,"examples":[{"fnId":107,"id":2,"query":"SELECT SESSIONTIMEZONE FROM DUAL;","exOrder":0}],"children":[]},{"id":108,"name":"SYS_EXTRACT_UTC","description":"SYS_EXTRACT_UTC(datetime_with_timezone) 형식으로 사용합니다.\nSYS_EXTRACT_UTC 함수는 시간대 오프셋이나 시간대 지역 이름을 포함한 datetime 값에서 UTC(협정 세계시, 이전에는 그리니치 평균시)를 추출합니다.","itemType":"F","parentId":28,"examples":[{"fnId":108,"id":2,"query":"SELECT SYS_EXTRACT_UTC(TIMESTAMP \u00272000-03-28 11:30:00.00 -08:00\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":110,"name":"SYSTIMESTAMP","description":"\nSYSTIMESTAMP 함수는 데이터베이스가 위치한 시스템의 시스템 날짜와 시간을 반환합니다. 반환되는 값은 TIMESTAMP WITH TIME ZONE 데이터 타입입니다. 이 함수는 소수 초와 시간대를 포함합니다.","itemType":"F","parentId":28,"examples":[{"fnId":110,"id":2,"query":"SELECT TO_CHAR(SYSTIMESTAMP, \u0027SSSSS.FF\u0027) FROM DUAL;","exOrder":0},{"fnId":110,"id":3,"query":"SELECT SYSTIMESTAMP FROM DUAL;","exOrder":0}],"children":[]},{"id":111,"name":"TO_CHAR(datetime)","description":"TO_CHAR (datetime/interval, fmt, nlsparam) 형식으로 사용합니다.\nTO_CHAR 함수는 DATE, TIMESTAMP, TIMESTAMP WITH TIME ZONE 또는 TIMESTAMP WITH LOCAL TIME ZONE 데이터 타입의 datetime 또는 interval 값을 지정된 날짜 형식 fmt에 따라 VARCHAR2 데이터 타입의 값으로 변환합니다. 만약 fmt를 생략하면, date는 다음과 같이 VARCHAR2 값으로 변환됩니다.","itemType":"F","parentId":28,"examples":[{"fnId":111,"id":2,"exOrder":0}],"children":[]},{"id":113,"name":"TO_TIMESTAMP_TZ","description":"TO_TIMESTAMP_TZ(char, fmt, nlsparam) 형식으로 사용합니다.\n선택적인 fmt 매개변수는 char의 형식을 지정합니다. 만약 fmt를 생략하면, char는 TIMESTAMP WITH TIME ZONE 데이터 타입의 기본 형식이어야 합니다. 선택적인 \u0027nlsparam\u0027 인수는 이 함수에서 날짜 변환의 TO_CHAR 함수와 동일한 목적으로 사용됩니다.","itemType":"F","parentId":28,"examples":[{"fnId":113,"id":2,"query":"SELECT TO_TIMESTAMP_TZ(\u00271999-12-01 11:00:00 -8:00\u0027, \u0027YYYY-MM-DD HH:MI:SS TZH:TZM\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":114,"name":"TO_DSINTERVAL","description":"TO_DSINTERVAL(char, nlsparam) 형식으로 사용합니다.\nTO_DSINTERVAL 함수는 CHAR, VARCHAR2, NCHAR 또는 NVARCHAR2 데이터 타입의 문자열을 INTERVAL DAY TO SECOND 값으로 변환합니다.","itemType":"F","parentId":28,"examples":[{"fnId":114,"id":2,"query":"SELECT employee_id, last_name FROM employees WHERE hire_date + TO_DSINTERVAL(\u0027100 10:00:00\u0027) \u003c\u003d DATE \u00271990-01-01\u0027;","exOrder":0}],"children":[]},{"id":115,"name":"TO_YMINTERVAL","description":"TO_YMINTERVAL(char) 형식으로 사용합니다.\nTO_YMINTERVAL 함수는 CHAR, VARCHAR2, NCHAR 또는 NVARCHAR2 데이터 타입의 문자열을 INTERVAL YEAR TO MONTH 타입으로 변환합니다. 여기서 char는 변환할 문자열입니다.","itemType":"F","parentId":28,"examples":[{"fnId":115,"id":2,"query":"SELECT hire_date, hire_date + TO_YMINTERVAL(\u002701-02\u0027) \"14 months\" FROM employees;","exOrder":0}],"children":[]},{"id":116,"name":"TRUNC(date)","description":"TRUNC(date, fmt) 형식으로 사용합니다.\n\nTRUNC (date) 함수는 날짜(date)의 시간 부분을 포맷 모델(fmt)로 지정한 단위로 잘라내어 반환합니다. 반환되는 값은 항상 DATE 데이터 타입이며, date에 다른 datetime 데이터 타입을 지정하더라도 그렇습니다. 만약 fmt을 생략하면 date는 가장 가까운 일(day)로 잘립니다.","itemType":"F","parentId":28,"examples":[{"fnId":116,"id":2,"query":"SELECT TRUNC(TO_DATE(\u002727-OCT-92\u0027,\u0027DD-MON-YY\u0027), \u0027YEAR\u0027) \"New Year\" FROM DUAL;","exOrder":0}],"children":[]},{"id":117,"name":"TZ_OFFSET","description":"TZ_OFFSET(sessiontimezone/dbtimezone) 형식으로 사용합니다.\nTZ_OFFSET 함수는 문장이 실행되는 날짜를 기준으로 인수에 해당하는 시간대 오프셋을 반환합니다. 유효한 시간대 이름, UTC로부터의 시간대 오프셋(그 자체로 반환됨), SESSIONTIMEZONE 또는 DBTIMEZONE 키워드를 입력할 수 있습니다. time_zone_name에 대한 유효한 값 목록은 V$TIMEZONE_NAMES 동적 성능 뷰의 TZNAME 열을 쿼리하여 확인할 수 있습니다.","itemType":"F","parentId":28,"examples":[{"fnId":117,"id":2,"exOrder":0}],"children":[]},{"id":106,"name":"ROUND(date)","description":"ROUND(date, fmt) 형식으로 사용합니다.\n\nROUND 함수는 형식 모델 fmt에 지정된 단위로 반올림된 날짜를 반환합니다. 반환되는 값은 항상 DATE 데이터 타입이며, date에 대해 다른 날짜 및 시간 데이터 타입을 지정한 경우에도 동일합니다. fmt를 생략하면 date가 가장 가까운 날짜로 반올림됩니다. 날짜 표현식은 DATE 값으로 해결되어야 합니다.","itemType":"F","parentId":28,"examples":[{"fnId":106,"id":2,"query":"SELECT ROUND (TO_DATE (\u002727-OCT-00\u0027),\u0027YEAR\u0027) \"New Year\" FROM DUAL;","exOrder":0}],"children":[]},{"id":109,"name":"SYSDATE","description":"SYSDATE 함수는 데이터베이스가 위치한 운영 체제에 설정된 현재 날짜와 시간을 반환합니다. 반환되는 값의 데이터 타입은 DATE이며, 반환되는 형식은 NLS_DATE_FORMAT 초기화 매개변수의 값에 따라 달라집니다. 이 함수는 인수를 필요로하지 않습니다. 분산 SQL 문에서는 이 함수가 로컬 데이터베이스의 운영 체제에 설정된 날짜와 시간을 반환합니다. 이 함수는 CHECK 제약 조건의 조건으로 사용할 수 없습니다.","itemType":"F","parentId":28,"examples":[{"fnId":109,"id":2,"query":"SELECT TO_CHAR (SYSDATE, \u0027MM-DD-YYYY HH24:MI:SS\u0027) \"NOW\" FROM DUAL;","exOrder":0}],"children":[]},{"id":112,"name":"TO_TIMESTAMP","description":"TO_TIMESTAMP(char, fmt, nlsparam) 형식으로 사용합니다.\nTO_TIMESTAMP 함수는 CHAR, VARCHAR2, NCHAR 또는 NVARCHAR2 데이터 타입의 char를 TIMESTAMP 데이터 타입의 값으로 변환합니다.\n옵션인 fmt는 char의 형식을 지정합니다. 만약 fmt를 생략하면, char는 TIMESTAMP 데이터 타입의 기본 형식이어야 합니다. 이는 NLS_TIMESTAMP_FORMAT 초기화 매개변수에 의해 결정됩니다. 선택적인 \u0027nlsparam\u0027 인수는 이 함수에서 날짜 변환의 TO_CHAR 함수와 동일한 목적으로 사용됩니다.\n이 함수는 CLOB 데이터를 직접 지원하지 않습니다. 하지만 CLOB는 암묵적인 데이터 변환을 통해 인수로 전달될 수 있습니다.","itemType":"F","parentId":28,"examples":[{"fnId":112,"id":2,"query":"SELECT TO_TIMESTAMP (\u002710-Sep-02 14:10:10.123000\u0027, \u0027DD-Mon-RR HH24:MI:SS.FF\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":99,"name":"LAST_DAY","description":"LAST_DAY(date) 형식으로 사용합니다.\nLAST_DAY 함수는 date가 포함된 월의 마지막 날짜를 반환합니다. 반환되는 데이터 타입은 항상 DATE이며, date의 데이터 타입과는 관계없습니다.","itemType":"F","parentId":28,"examples":[{"fnId":99,"id":2,"query":"SELECT SYSDATE,LAST_DAY(SYSDATE) \"Last\", LAST_DAY(SYSDATE) - SYSDATE \"Days Left\" FROM DUAL;","exOrder":0}],"children":[]}]},{"id":29,"name":"변환 함수(Conversion Functions)","description":"데이터 타입을 다른 타입으로 변환합니다. 함수의 이름은 일반적으로 datatype To datatype 형식입니다.\n첫 번째 datatype은 입력 데이터의 타입, 두 번째 datatype은 출력 데이터 타입입니다.","itemType":"C","parentId":8,"children":[{"id":124,"name":"DECOMPOSE","description":"DECOMPOSE(string, CANONICAL/COMPATIBILITY) 형식으로 사용합니다.\nDECOMPOSE 함수는 유니코드 문자에 대해서만 유효합니다. DECOMPOSE 함수는 어떤 데이터 타입의 문자열을 인수로 받아 해당 문자열을 분해한 후 동일한 문자 집합에서의 유니코드 문자열을 반환합니다. 예를 들어, o-umlaut 코드 포인트는 \"o\" 코드 포인트 뒤에 umlaut 코드 포인트로 반환됩니다.","itemType":"F","parentId":29,"examples":[{"fnId":124,"id":2,"query":"SELECT DECOMPOSE (\u0027Châteaux\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":144,"name":"TO_SINGLE_BYTE","description":"TO_SINGLE_BYTE(char) 형식으로 사용합니다.\nTO_SINGLE_BYTE 함수는 char의 모든 멀티바이트 문자를 해당하는 싱글바이트 문자로 변환하여 반환합니다. char은 CHAR, VARCHAR2, NCHAR 또는 NVARCHAR2 데이터 타입일 수 있으며, 반환되는 값의 데이터 타입은 char과 동일합니다.\nchar에 있는 어떤 멀티바이트 문자라도 싱글바이트와 대응되지 않는 경우, 출력에서는 멀티바이트 문자로 표시됩니다. 이 함수는 데이터베이스 문자 집합에 싱글바이트와 멀티바이트 문자가 모두 포함되어 있는 경우에 유용합니다.\n이 함수는 CLOB 데이터를 직접 지원하지 않습니다. 그러나 CLOB는 암묵적인 데이터 변환을 통해 인수로 전달할 수 있습니다.","itemType":"F","parentId":29,"examples":[{"fnId":144,"id":2,"query":"SELECT TO_SINGLE_BYTE( CHR(15711393)) FROM DUAL;","exOrder":0},{"fnId":144,"id":3,"query":"SELECT TO_SINGLE_BYTE(\u0027안녕하세요\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":145,"name":"TRANSLATE ... USING","description":"TRANSLATE(TEXT USING CHAR_CS/NCHAR_CS) 형식으로 사용합니다.\nTRANSLATE ... USING은 데이터베이스 문자 집합과 국가 문자 집합 간의 변환을 위해 지정된 문자 집합으로 텍스트를 변환합니다.\nTRANSLATE ... USING 구문은 데이터 타입을 직접 지정하는 것이 아니기 때문에 데이터 유형이나 데이터 타입으로 번역할 필요는 없습니다. 이 구문은 문자열의 문자를 지정된 문자 집합으로 변환하는 역할을 합니다.\n","itemType":"F","parentId":29,"examples":[{"fnId":145,"id":2,"query":"UPDATE translate_tab SET char_col \u003d TRANSLATE (nchar_col USING CHAR_CS);","exOrder":0}],"children":[]},{"id":146,"name":"UNISTR","description":"UNISTR(string) 형식으로 사용합니다.\nUNISTR 함수는 텍스트 문자열을 인자로 받아서 국가 문자 집합으로 변환한 결과를 반환합니다. 데이터베이스의 국가 문자 집합은 AL16UTF16 또는 UTF8일 수 있습니다. UNISTR 함수는 유니코드 문자열 리터럴을 지원하여 문자열 내의 문자의 유니코드 인코딩 값을 지정할 수 있습니다. 이는 예를 들어 NCHAR 열에 데이터를 삽입할 때 유용합니다.\n유니코드 인코딩 값은 \u0027\\xxxx\u0027 형식을 가지며, \u0027xxxx\u0027는 UCS-2 인코딩 형식에서 문자의 16진수 값입니다. 문자열 자체에 백슬래시를 포함시키려면 백슬래시를 다른 백슬래시로 이스케이프(\\) 해야 합니다.\n이식성과 데이터 보존을 위해, UNISTR 문자열 인자에서는 ASCII 문자와 유니코드 인코딩 값을 지정하는 것이 좋습니다.\n","itemType":"F","parentId":29,"examples":[{"fnId":146,"id":2,"query":"SELECT UNISTR(\u0027\\0041\\0042\\0043\u0027) FROM DUAL;","exOrder":0},{"fnId":146,"id":3,"query":"SELECT UNISTR(\u0027abc\\00e5\\00f1\\00f6\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":134,"name":"TO_CHAR(number)","description":"TO_CHAR(n, fmt, nlsparam) 형식으로 사용합니다.\nTO_CHAR 함수는 숫자 n을 VARCHAR2 데이터 타입으로 변환합니다. 옵션으로 숫자 형식 fmt을 지정할 수 있습니다. 값 n은 NUMBER, BINARY_FLOAT 또는 BINARY_DOUBLE 유형일 수 있습니다. 만약 fmt를 생략하면, n은 자릿수에 맞게 자동으로 VARCHAR2 값으로 변환됩니다.","itemType":"F","parentId":29,"examples":[{"fnId":134,"id":2,"query":"SELECT TO_CHAR(12345.6789, \u002799999.9999\u0027) AS char_value FROM DUAL;","exOrder":0}],"children":[]},{"id":122,"name":"COMPOSE","description":"COMPOSE(char) 형식으로 사용합니다.\nCOMPOSE 함수는 어떤 데이터 타입의 문자열을 인수로 받고, 입력과 동일한 문자 집합에서 완전히 정규화된 형태의 유니코드 문자열을 반환합니다. char는 CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB 또는 NCLOB와 같은 데이터 타입일 수 있습니다. 예를 들어, o 코드 포인트가 어우무트 코드 포인트로 수정된 경우, o-umlaut 코드 포인트로 반환됩니다.","itemType":"F","parentId":29,"examples":[{"fnId":122,"id":2,"query":"SELECT COMPOSE ( \u0027o\u0027 || UNISTR(\u0027\\0308\u0027) ) FROM DUAL; ","exOrder":0}],"children":[]},{"id":118,"name":"ASCIISTR","description":"ASCIISTR(char) 형식으로 사용합니다.\nASCIISTR 함수는 인수로 어떤 문자 집합의 문자열을 받고 해당 문자열의 ASCII 버전을 반환합니다. 비-ASCII 문자는 \\xxxx 형식으로 변환되며, 여기서 xxxx는 UTF-16 코드 유닛을 나타냅니다.","itemType":"F","parentId":29,"examples":[{"fnId":118,"id":2,"query":"SELECT ASCIISTR(\u0027ABÄCDE\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":119,"name":"BIN_TO_NUM","description":"BIN_TO_NUM(expr) 형식으로 사용합니다.\nBIN_TO_NUM 함수는 비트 벡터를 해당하는 숫자로 변환합니다. 이 함수의 각 인수는 비트 벡터에서 하나의 비트를 나타냅니다. 이 함수는 숫자 데이터 유형 또는 NUMBER로 암시적으로 변환할 수 있는 비숫자 데이터 유형을 인수로 받습니다. 각 expr은 0 또는 1로 평가되어야 합니다. 이 함수는 Oracle NUMBER를 반환합니다.\nBIN_TO_NUM 함수는 그룹 집합을 사용하여 자주 사용되는 그룹을 선택하는 데이터 웨어하우징 애플리케이션에서 유용하게 사용됩니다.","itemType":"F","parentId":29,"examples":[{"fnId":119,"id":2,"query":"SELECT BIN_TO_NUM(1,0,1,0) FROM DUAL; ","exOrder":0}],"children":[]},{"id":120,"name":"CAST","description":"CAST(expr) / CAST(MULTISET(subquery)) AS typename) 형식으로 사용합니다.\nCAST 함수는 내장 데이터 유형 또는 컬렉션 유형의 값을 다른 내장 데이터 유형이나 컬렉션 유형으로 변환합니다.\nCAST 함수를 사용하면 하나의 유형을 다른 내장 데이터 유형이나 컬렉션 유형으로 변환할 수 있습니다. 이름 없는 피연산자(예: 날짜 또는 하위 쿼리의 결과 집합)나 명명된 컬렉션(예: varray 또는 중첩 테이블)을 유형 호환성이 있는 데이터 유형이나 명명된 컬렉션으로 변환할 수 있습니다. type_name은 내장 데이터 유형이나 컬렉션 유형의 이름이어야 하며, 피연산자는 내장 데이터 유형이거나 컬렉션 값으로 평가되어야 합니다.\n피연산자 expr은 내장 데이터 유형, 컬렉션 유형 또는 AnyData 유형의 인스턴스일 수 있습니다. expr이 AnyData 유형의 인스턴스인 경우, CAST는 AnyData 인스턴스의 값을 추출하려고 하며, 변환 대상 유형과 일치하는 경우 해당 값을 반환하고, 그렇지 않은 경우 null을 반환합니다. MULTISET은 Oracle Database에게 하위 쿼리의 결과 집합을 가져와 컬렉션 값을 반환하도록 지시합니다. 표 7-1은 어떤 내장 데이터 유형을 어떤 다른 내장 데이터 유형으로 캐스팅할 수 있는지 보여줍니다. (CAST는 LONG, LONG RAW, LOB 데이터 유형 또는 Oracle이 제공하는 유형을 지원하지 않습니다.)","itemType":"F","parentId":29,"examples":[{"fnId":120,"id":2,"query":"SELECT s.custno, s.name, CAST(MULTISET(SELECT ca.street_address, ca.postal_code, ca.city, ca.state_province, ca.country_id FROM cust_address ca WHERE s.custno \u003d ca.custno) AS address_book_t) FROM cust_short s;","exOrder":0},{"fnId":120,"id":3,"query":"SELECT CAST(s.addresses AS address_book_t) FROM states s WHERE s.state_id \u003d 111;","exOrder":0}],"children":[]},{"id":121,"name":"CHARTOROWID","description":"CHARTOROWID(char) 형식으로 사용합니다.\nCHARTOROWID 함수는 CHAR, VARCHAR2, NCHAR, NVARCHAR2 데이터 타입의 값을 ROWID 데이터 타입으로 변환합니다.\n이 함수는 CLOB 데이터를 직접적으로 지원하지 않습니다. 그러나 CLOB는 암시적 데이터 변환을 통해 인수로 전달될 수 있습니다.","itemType":"F","parentId":29,"examples":[{"fnId":121,"id":2,"query":"SELECT last_name FROM employees WHERE ROWID \u003d CHARTOROWID(\u0027AAAFd1AAFAAAABSAA/\u0027);","exOrder":0}],"children":[]},{"id":123,"name":"CONVERT","description":"CONVERT(char, dest_char_set, source_char_set) 형식으로 사용합니다.\nCONVERT 함수는 문자열을 한 문자셋에서 다른 문자셋으로 변환합니다. 반환되는 값의 데이터 타입은 VARCHAR2입니다.\nchar 인수는 변환할 값입니다. CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB 또는 NCLOB와 같은 모든 데이터 타입이 될 수 있습니다.\ndest_char_set 인수는 char이 변환되는 문자셋의 이름입니다.\nsource_char_set 인수는 데이터베이스에 char이 저장된 문자셋의 이름입니다. 기본값은 데이터베이스 문자셋입니다.\n대상 및 출처 문자셋 인수는 리터럴 또는 문자셋 이름을 포함하는 열일 수 있습니다.\n문자 변환에서 완전한 대응을 위해서는 대상 문자셋에 출처 문자셋에 정의된 모든 문자의 표현이 포함되어야 합니다. 대상 문자셋에 문자가 존재하지 않을 경우 대체 문자가 나타납니다. 대체 문자는 문자셋 정의의 일부로 정의할 수 있습니다.","itemType":"F","parentId":29,"examples":[{"fnId":123,"id":2,"query":"SELECT CONVERT(\u0027Ä Ê Í Ó Ø A B C D E \u0027, \u0027US7ASCII\u0027, \u0027WE8ISO8859P1\u0027) FROM DUAL; ","exOrder":0}],"children":[]},{"id":125,"name":"HEXTORAW","description":"HEXTORAW(char) 형식으로 사용합니다.\nHEXTORAW 함수는 CHAR, VARCHAR2, NCHAR, 또는 NVARCHAR2 문자 집합에서 16진수 숫자를 포함하는 char를 raw 값으로 변환합니다.\n이 함수는 CLOB 데이터를 직접적으로 지원하지 않습니다. 그러나 CLOB는 암묵적인 데이터 변환을 통해 인수로 전달될 수 있습니다.","itemType":"F","parentId":29,"examples":[{"fnId":125,"id":2,"query":"SELECT HEXTORAW(\u002748656C6C6F20576F726C64\u0027) AS result FROM dual;","exOrder":0}],"children":[]},{"id":126,"name":"RAWTOHEX","description":"RAWTOHEX(raw) 형식으로 사용합니다.\nRAWTOHEX 함수는 raw 값을 해당하는 16진수 값으로 변환하여 문자열 형태로 반환합니다. raw 인수는 RAW 데이터 유형이어야 합니다.\n이 함수는 PL/SQL 블록 내에서 호출되는 경우 BLOB 인수를 지정할 수 있습니다.","itemType":"F","parentId":29,"examples":[{"fnId":126,"id":2,"query":"SELECT RAWTOHEX(raw_column) \"Graphics\" FROM graphics;","exOrder":0},{"fnId":126,"id":3,"query":"SELECT RAWTOHEX(\u0027Hello World\u0027) AS result FROM dual;","exOrder":0}],"children":[]},{"id":127,"name":"ROWIDTOCHAR","description":"ROWIDTOCHAR(rowid) 형식으로 사용합니다.\nROWIDTOCHAR 함수는 rowid 값을 VARCHAR2 데이터 타입으로 변환합니다. 이 변환의 결과는 항상 18자리입니다.","itemType":"F","parentId":29,"examples":[{"fnId":127,"id":2,"query":"SELECT ROWID FROM employees WHERE ROWIDTOCHAR(ROWID) LIKE \u0027%SAAb%\u0027;","exOrder":0}],"children":[]},{"id":128,"name":"ROWIDTONCHAR","description":"ROWIDTONCHAR(rowid) 형식으로 사용합니다.\nROWIDTONCHAR 함수는 rowid 값을 NVARCHAR2 데이터 타입으로 변환합니다. 이 변환의 결과는 항상 18자리입니다.","itemType":"F","parentId":29,"examples":[{"fnId":128,"id":2,"query":"SELECT LENGTHB( ROWIDTONCHAR(ROWID) ), ROWIDTONCHAR(ROWID) FROM employees;","exOrder":0}],"children":[]},{"id":129,"name":"SCN_TO_TIMESTAMP","description":"SCN_TO_TIMESTAMP(number) 형식으로 사용합니다.\nSCN_TO_TIMESTAMP 함수는 SCN(System Change Number)으로 평가되는 숫자를 인수로 받아 해당 SCN과 관련된 대략적인 타임스탬프를 반환합니다. 반환값은 TIMESTAMP 데이터 타입입니다. 이 함수는 언제든지 SCN과 관련된 타임스탬프를 알고 싶을 때 유용하게 사용할 수 있습니다. 예를 들어, ORA_ROWSCN 의사 컬럼과 함께 사용하여 행에 대한 최신 변경 사항에 대한 타임스탬프를 연결하는 데 사용할 수 있습니다.","itemType":"F","parentId":29,"examples":[{"fnId":129,"id":2,"query":"SELECT SCN_TO_TIMESTAMP(ORA_ROWSCN) FROM employees WHERE employee_id \u003d 188;","exOrder":0},{"fnId":129,"id":3,"query":"SELECT SCN_TO_TIMESTAMP(123456789) AS timestamp FROM DUAL;","exOrder":0}],"children":[]},{"id":130,"name":"TIMESTAMP_TO_SCN","description":"TIMESTAMP_TO_SCN(timestamp) 형식으로 사용합니다.\nTIMESTAMP_TO_SCN 함수는 타임스탬프 값으로 인자를 받아 해당 타임스탬프와 연관된 근사적인 시스템 변경 번호(SCN)를 반환합니다. 반환되는 값의 데이터 타입은 NUMBER입니다. 이 함수는 특정 타임스탬프와 관련된 SCN을 알고자 할 때 유용합니다.","itemType":"F","parentId":29,"examples":[{"fnId":130,"id":2,"query":"SELECT TIMESTAMP_TO_SCN(TO_TIMESTAMP(\u00272023-05-30 10:00:00\u0027, \u0027YYYY-MM-DD HH24:MI:SS\u0027)) AS scn FROM DUAL;","exOrder":0}],"children":[]},{"id":131,"name":"TO_BINARY_DOUBLE","description":"TO_BINARY_DOUBLE(expr, fmt, nlsparam) 형식으로 사용합니다.\nTO_BINARY_DOUBLE 함수는 배정밀도 부동 소수점 숫자(double-precision floating-point number)를 반환합니다.","itemType":"F","parentId":29,"examples":[{"fnId":131,"id":2,"query":"SELECT TO_BINARY_DOUBLE(3.14) AS binary_double FROM DUAL;","exOrder":0}],"children":[]},{"id":132,"name":"TO_BINARY_FLOAT","description":"TO_BINARY_FLOAT(expr, fmt, nlsparam) 형식으로 사용합니다.\nTO_BINARY_FLOAT 함수는 단정밀도 부동 소수점 숫자(single-precision floating-point number)를 반환합니다.","itemType":"F","parentId":29,"examples":[{"fnId":132,"id":2,"query":"SELECT TO_BINARY_FLOAT(1.23) AS binary_float FROM DAUL;","exOrder":0}],"children":[]},{"id":133,"name":"TO_CHAR(character)","description":"TO_CHAR(nchar/clob/nclob) 형식으로 사용합니다.\nTO_CHAR 함수는 NCHAR, NVARCHAR2, CLOB 또는 NCLOB 데이터를 데이터베이스 문자 집합으로 변환합니다.","itemType":"F","parentId":29,"examples":[{"fnId":133,"id":2,"query":"SELECT TO_CHAR(N\u0027안녕하세요\u0027, \u0027YYYY-MM-DD\u0027) AS char_value FROM DUAL;","exOrder":0},{"fnId":133,"id":3,"query":"SELECT TO_CHAR(\u002701110\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":135,"name":"TO_CLOB","description":"TO_CLOB(lob_column/char) 형식으로 사용합니다.\nTO_CLOB 함수는 LOB 열이나 다른 문자열 데이터를 NCLOB 값을 CLOB 값으로 변환합니다. char은 CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB 또는 NCLOB와 같은 데이터 타입일 수 있습니다. Oracle Database는 이 함수를 실행할 때 내부적으로 LOB 데이터를 국가 문자 집합에서 데이터베이스 문자 집합으로 변환합니다.","itemType":"F","parentId":29,"examples":[{"fnId":135,"id":2,"query":"SELECT TO_CLOB(\u0027Hello, world!\u0027) AS clob_value FROM DUAL;","exOrder":0}],"children":[]},{"id":136,"name":"TO_DATE","description":"TO_DATE(char, fmt, nlsparam) 형식으로 사용합니다.\nTO_DATE 함수는 CHAR, VARCHAR2, NCHAR 또는 NVARCHAR2 데이터 유형의 char 값을 DATE 데이터 유형의 값으로 변환합니다. fmt은 char의 형식을 지정하는 날짜 및 시간 모델 형식입니다. 만약 fmt를 생략하면 char은 기본 날짜 형식이어야 합니다. fmt가 J인 경우 Julian 형식이므로 char은 정수여야 합니다.\n","itemType":"F","parentId":29,"examples":[{"fnId":136,"id":2,"query":"SELECT TO_DATE(\u0027January 15, 1989, 11:00 A.M.\u0027,\u0027Month dd, YYYY, HH:MI A.M.\u0027,\u0027NLS_DATE_LANGUAGE \u003d American\u0027) FROM DUAL;","exOrder":0},{"fnId":136,"id":3,"query":"SELECT TO_DATE(\u00272023-05-30\u0027, \u0027YYYY-MM-DD\u0027) AS date_value FROM DUAL;","exOrder":0}],"children":[]},{"id":137,"name":"TO_LOB","description":"TO_LOB(long_column) 형식으로 사용합니다.\nTO_LOB 함수는 long_column의 LONG 또는 LONG RAW 값을 LOB 값으로 변환합니다. 이 함수는 LONG 또는 LONG RAW 열에만 적용할 수 있으며, INSERT 문의 하위 쿼리의 SELECT 목록에서만 사용할 수 있습니다.\n이 함수를 사용하기 전에, 변환된 LONG 값을 수신할 LOB 열을 생성해야 합니다. LONG 값을 변환하려면 CLOB 열을 생성하십시오. LONG RAW 값을 변환하려면 BLOB 열을 생성하십시오.\nTO_LOB 함수를 사용하여 LONG 열을 LOB 열로 변환하는 것은 CREATE TABLE ... AS SELECT 문의 하위 쿼리에서 인덱스 구성 테이블을 생성하는 경우에는 사용할 수 없습니다. 대신 LONG 열을 포함하지 않고 인덱스 구성 테이블을 생성한 후 INSERT ... AS SELECT 문에서 TO_LOB 함수를 사용하십시오.","itemType":"F","parentId":29,"examples":[{"fnId":137,"id":2,"query":"INSERT INTO target_table (lob_column) SELECT TO_LOB(long_column) FROM source_table;","exOrder":0}],"children":[]},{"id":138,"name":"TO_MULTI_BYTE","description":"TO_MULTI_BYTE(char) 형식으로 사용합니다.\nTO_MULTI_BYTE 함수는 char의 모든 단일바이트 문자를 해당하는 다중바이트 문자로 변환한 char을 반환합니다. char는 CHAR, VARCHAR2, NCHAR 또는 NVARCHAR2 데이터 유형일 수 있습니다. 반환된 값은 char과 동일한 데이터 유형입니다.\nchar에 있는 다중바이트 등가물이 없는 단일바이트 문자는 출력 문자열에 단일바이트 문자로 표시됩니다. 이 함수는 데이터베이스 문자 집합이 단일바이트와 다중바이트 문자를 모두 포함하는 경우에만 유용합니다.\n이 함수는 CLOB 데이터를 직접 지원하지 않습니다. 그러나 CLOB는 암시적 데이터 변환을 통해 인수로 전달될 수 있습니다.","itemType":"F","parentId":29,"examples":[{"fnId":138,"id":2,"query":"SELECT dump(TO_MULTI_BYTE( \u0027A\u0027)) FROM DUAL; ","exOrder":0},{"fnId":138,"id":3,"query":"SELECT TO_MULTI_BYTE(\u0027Hello\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":139,"name":"TO_NCHAR(character)","description":"TO_NCHAR(char/clob/nclob, fmt, nlsparam) 형식으로 사용합니다.\nTO_NCHAR 함수는 데이터베이스 문자 집합에서 국가 문자 집합으로 문자열, CLOB 또는 NCLOB 값을 변환합니다. \n","itemType":"F","parentId":29,"examples":[{"fnId":139,"id":2,"query":"SELECT TO_NCHAR(\u0027Hello\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":140,"name":"TO_NCHAR(datetime)","description":"TO_NCHAR(datetime/interval, fmt, nlsparam)형식으로 사용합니다.\nTO_NCHAR 함수는 데이터베이스 문자 집합에서 국가 문자 집합으로 DATE, TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE, INTERVAL MONTH TO YEAR 또는 INTERVAL DAY TO SECOND 데이터 유형의 날짜/시간 또는 간격 값을 변환합니다.","itemType":"F","parentId":29,"examples":[{"fnId":140,"id":2,"query":"SELECT TO_NCHAR(TIMESTAMP \u00272023-05-30 10:15:00\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":141,"name":"TO_NCHAR(number)","description":"TO_NCHAR(n, fmt, nlsparam) 형식으로 사용합니다.\nTO_NCHAR 함수는 숫자 n을 국가 문자 집합으로 변환하여 문자열로 반환합니다. 값 n은 NUMBER, BINARY_FLOAT 또는 BINARY_DOUBLE 데이터 타입일 수 있습니다. 이 함수는 인자와 동일한 유형의 값을 반환합니다. 선택적인 fmt 및 \u0027nlsparam\u0027은 DATE, TIMESTAMP, TIMESTAMP WITH TIME ZONE, TIMESTAMP WITH LOCAL TIME ZONE, INTERVAL MONTH TO YEAR 또는 INTERVAL DAY TO SECOND 데이터 타입일 수 있습니다.\n","itemType":"F","parentId":29,"examples":[{"fnId":141,"id":2,"query":"SELECT TO_NCHAR(123.45) FROM DUAL;","exOrder":0}],"children":[]},{"id":142,"name":"TO_NCLOB","description":"TO_NCLOB(lob_column/char) 형식으로 사용합니다.\nTO_NCLOB 함수는 LOB 열이나 다른 문자열의 CLOB 값을 NCLOB 값으로 변환합니다. char는 CHAR, VARCHAR2, NCHAR, NVARCHAR2, CLOB 또는 NCLOB 데이터 타입 중 하나일 수 있습니다. Oracle Database는 이 함수를 사용하여 char의 문자 집합을 데이터베이스 문자 집합에서 국가 문자 집합으로 변환합니다.\n","itemType":"F","parentId":29,"examples":[{"fnId":142,"id":2,"query":"SELECT TO_NCLOB(\u0027Hello, World!\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":143,"name":"TO_NUMBER","description":"TO_NUMBER(expr, fmt, nlsparam) 형식으로 사용합니다.\nTO_NUMBER 함수는 expr을 NUMBER 데이터 타입의 값으로 변환합니다. expr은 BINARY_FLOAT 또는 BINARY_DOUBLE 값이거나, 숫자를 포함하는 CHAR, VARCHAR2, NCHAR, NVARCHAR2 데이터 타입의 값일 수 있으며, 선택적인 형식 모델 fmt에 지정된 형식에 맞는 숫자입니다.\n","itemType":"F","parentId":29,"examples":[{"fnId":143,"id":2,"query":"SELECT TO_NUMBER(\u0027123.45\u0027) FROM DUAL;","exOrder":0},{"fnId":143,"id":3,"query":"SELECT TO_NUMBER(\u0027-AusDollars100\u0027,\u0027L9G999D99\u0027, \u0027 NLS_NUMERIC_CHARACTERS \u003d \u0027\u0027,.\u0027\u0027NLS_CURRENCY \u003d \u0027\u0027AusDollars\u0027\u0027\u0027) \"Amount\" FROM DUAL;","exOrder":0}],"children":[]}]},{"id":31,"name":"객체 참조 함수(Object Reference Functions)","description":"객체 참조 함수는 지정된 객체 타입의 객체에 대한 참조인 REF를 조작합니다.","itemType":"C","parentId":8,"children":[{"id":147,"name":"DEREF","description":"DEREF(expr) 형식으로 사용합니다.\nDEREF 함수는 인자로 받은 expr의 객체 참조를 반환합니다. expr은 객체에 대한 REF를 반환해야 합니다. 이 함수를 쿼리에서 사용하지 않으면 Oracle 데이터베이스는 REF의 객체 ID를 반환합니다.\n","itemType":"F","parentId":31,"examples":[{"fnId":147,"id":2,"query":"SELECT DEREF(ref_column) FROM DUAL;","exOrder":0}],"children":[]},{"id":148,"name":"MAKE_REF","description":"MAKE_REF(table/view, key) 형식으로 사용합니다.\nMAKE_REF 함수는 객체 뷰(object view)의 행이나 객체 테이블(object table)의 행에 대한 REF를 생성합니다. 이 때, 객체 식별자(object identifier)가 기본 키(primary key)에 기반하여 사용됩니다.\n","itemType":"F","parentId":31,"examples":[{"fnId":148,"id":2,"query":"SELECT MAKE_REF(object_table, primary_key_column) FROM DUAL;","exOrder":0},{"fnId":148,"id":3,"query":"SELECT MAKE_REF (oc_inventories, 3003) FROM DUAL;","exOrder":0}],"children":[]},{"id":149,"name":"REF","description":"REF(correlation_variable) 형식으로 사용합니다.\nREF 함수는 인수로 객체 테이블이나 객체 뷰와 연관된 상관 변수(테이블 별칭)를 사용합니다. 변수나 행에 바인딩된 객체 인스턴스에 대한 REF 값을 반환합니다.\n","itemType":"F","parentId":31,"examples":[{"fnId":149,"id":2,"query":"SELECT REF(e) FROM addresses e;","exOrder":0}],"children":[]},{"id":150,"name":"REFTOHEX","description":"REFTOHEX(expr) 형식으로 사용합니다.\nREFTOHEX 함수는 인수로 전달된 expr을 해당하는 16진수 값으로 변환하여 문자열로 반환합니다. expr은 REF 값을 반환해야 합니다.\n","itemType":"F","parentId":31,"examples":[{"fnId":150,"id":2,"query":"SELECT REFTOHEX(ref_column) FROM your_table;","exOrder":0}],"children":[]},{"id":151,"name":"VALUE","description":"VALUE(correlation_variable) 형식으로 사용합니다.\nVALUE 함수는 인수로 전달된 correlation variable (테이블 별칭)에 연결된 객체 테이블의 행과 관련된 객체 인스턴스를 반환합니다. 객체 인스턴스의 유형은 객체 테이블과 동일한 유형입니다.\n","itemType":"F","parentId":31,"examples":[{"fnId":151,"id":2,"query":"SELECT VALUE(alias) FROM your_table alias;","exOrder":0}],"children":[]}]},{"id":36,"name":"기타 단일행 함수(Miscellaneous Single-Row Functions)","description":"다른 단일행 함수들의 범주에 속하지 않는 함수들입니다.","itemType":"C","parentId":8,"children":[{"id":183,"name":"SYS_TYPEID","description":"SYS_TYPEID(object_type_value) 형식으로 사용합니다.\nSYS_TYPEID 함수는 피연산자의 가장 구체적인 유형의 typeid를 반환합니다. 이 값은 주로 대체 가능한 열의 유형 구별 열(type-discriminant column)을 식별하는 데 사용됩니다. 예를 들어, SYS_TYPEID가 반환하는 값을 사용하여 유형 구별 열에 인덱스를 생성할 수 있습니다.\n이 함수는 객체 유형 피연산자에만 사용할 수 있습니다. 모든 최종 루트 객체 유형은(즉, 유형 계층에 속하지 않는 최종 유형) null typeid를 가지고 있습니다. Oracle Database는 유형 계층에 속하는 모든 유형에 고유한 non-null typeid를 할당합니다.","itemType":"F","parentId":36,"examples":[{"fnId":183,"id":2,"query":"CREATE INDEX type_discriminant_idx ON table_name (SYS_TYPEID(type_discriminant_column));","exOrder":0}],"children":[]},{"id":184,"name":"SYS_XMLAGG","description":"SYS_XMLAGG(expr, fmt) 형식으로 사용합니다.\nSYS_XMLAGG 함수는 expr로 표현된 모든 XML 문서나 조각을 집계하여 단일 XML 문서를 생성합니다. 이 함수는 기본 이름이 \"ROWSET\"인 새로운 둘러싸는 요소를 추가합니다. XML 문서를 다르게 포맷하려면 XMLFormat 객체의 인스턴스인 fmt을 지정하세요.\n","itemType":"F","parentId":36,"examples":[{"fnId":184,"id":2,"query":"SELECT SYS_XMLAGG(expr) AS aggregated_xml FROM your_table;","exOrder":0}],"children":[]},{"id":185,"name":"SYS_XMLGEN","description":"SYS_XMLGEN(expr, fmt) 형식으로 사용합니다.\nSYS_XMLGEN 함수는 데이터베이스의 특정 행과 열을 평가하는 표현식을 사용하여 XMLType 유형의 인스턴스를 반환합니다. expr은 스칼라 값, 사용자 정의 유형 또는 XMLType 인스턴스가 될 수 있습니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":185,"id":2,"query":"SELECT SYS_XMLGEN(expr) AS generated_xml FROM your_table;","exOrder":0}],"children":[]},{"id":186,"name":"UID","description":"UID는 세션 사용자(로그인한 사용자)를 고유하게 식별하는 정수값을 반환합니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":186,"id":2,"query":"SELECT UID FROM DUAL;","exOrder":0}],"children":[]},{"id":187,"name":"UPDATEXML","description":"UPDATEXML(XMLType_instance, XPath_string, value_expr, namespace_string) 형식으로 사용합니다.\nUPDATEXML은 XMLType 인스턴스와 XPath-값 쌍을 인수로 받아 업데이트된 값이 포함된 XMLType 인스턴스를 반환합니다. XPath_string이 XML 요소인 경우, 해당하는 value_expr은 XMLType 인스턴스여야 합니다. XPath_string이 속성이나 텍스트 노드인 경우, value_expr은 스칼라 데이터 유형이 될 수 있습니다. 각 XPath_string의 대상과 해당하는 value_expr의 데이터 유형이 일치해야 합니다. 선택적인 namespace_string은 VARCHAR2 값을 해석해 기본 매핑 또는 접두사에 대한 네임스페이스 매핑을 지정하며, Oracle Database가 XPath 식을 평가할 때 사용합니다.\nXML 요소를 null로 업데이트하면 Oracle은 요소의 속성과 자식을 제거하고 요소 자체가 비어 있게 됩니다. 요소의 텍스트 노드를 null로 업데이트하면 Oracle은 요소의 텍스트 값을 제거하고 요소 자체는 비어 있지만 남아 있습니다.\n대부분의 경우, 이 함수는 XML 문서를 메모리에 구성하고 값을 업데이트합니다. 그러나 UPDATEXML은 개체-관계형 열에 대한 UPDATE 문에 최적화되어 함수가 열 자체에서 값을 직접 업데이트합니다. \n","itemType":"F","parentId":36,"examples":[{"fnId":187,"id":2,"query":"UPDATE your_table SET xml_column \u003d UPDATEXML(xml_column, \u0027/root/element\u0027, XMLType(\u0027\u003cupdated_value\u003enew_value\u003c/updated_value\u003e\u0027)) WHERE condition;","exOrder":0}],"children":[]},{"id":188,"name":"USER","description":"USER 함수는 세션 사용자(로그인한 사용자)의 이름을 VARCHAR2 데이터 타입으로 반환합니다. Oracle Database는 이 함수의 값을 공백 패딩된 비교 의미론으로 비교합니다.\n분산 SQL 문에서 UID와 USER 함수는 함께 사용하여 로컬 데이터베이스의 사용자를 식별합니다. 이러한 함수는 CHECK 제약 조건의 조건절에서 사용할 수 없습니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":188,"id":2,"query":"SELECT USER, UID FROM DUAL;","exOrder":0}],"children":[]},{"id":189,"name":"USERENV","description":"USERENV(parameter) 형식으로 사용합니다.\nUSERENV 함수는 현재 세션에 대한 정보를 반환합니다. 이 정보는 애플리케이션별 감사 추적 테이블 작성이나 세션에서 현재 사용되는 언어별 문자를 결정하는 데 유용할 수 있습니다. USERENV 함수는 CHECK 제약 조건의 조건절에서 사용할 수 없습니다. Table 7-12는 매개변수 인수에 대한 값들을 설명합니다.\nUSERENV의 모든 호출은 세션ID, ENTRYID 및 COMMITSCN 매개변수를 제외하고는 VARCHAR2 데이터를 반환합니다. 세션ID, ENTRYID 및 COMMITSCN 매개변수에 대한 호출은 NUMBER를 반환합니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":189,"id":2,"query":"SELECT USERENV(\u0027LANGUAGE\u0027) \"Language\" FROM DUAL;","exOrder":0}],"children":[]},{"id":190,"name":"VSIZE","description":"VSIZE(expr) 형식으로 사용합니다.\nVSIZE 함수는 expr의 내부 표현에서의 바이트 수를 반환합니다. 만약 expr이 null이라면 이 함수는 null을 반환합니다.\n이 함수는 CLOB 데이터를 직접적으로 지원하지 않습니다. 그러나 CLOB는 암묵적인 데이터 변환을 통해 인수로 전달될 수 있습니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":190,"id":2,"query":"SELECT VSIZE(\u0027Hello\u0027) AS byte_size FROM DUAL;","exOrder":0},{"fnId":190,"id":3,"query":"SELECT VSIZE(NULL) AS byte_size FROM DUAL;","exOrder":0},{"fnId":190,"id":4,"query":"SELECT VSIZE(CAST(your_clob_column AS VARCHAR2(4000))) AS byte_size FROM your_table;","exOrder":0}],"children":[]},{"id":191,"name":"XMLAGG","description":"XMLAGG(XMLType_instance) 형식으로 사용합니다.\nXMLAgg는 집계 함수입니다. XML 단편들의 컬렉션을 가져와 집계된 XML 문서를 반환합니다. 결과에서 null을 반환하는 인수는 제외됩니다.\nXMLAgg는 SYS_XMLAgg와 유사하지만, XMLAgg는 노드 컬렉션을 반환하지만 XMLFormat 객체를 사용하여 서식을 지원하지 않습니다. 또한 XMLAgg는 SYS_XMLAgg와 달리 출력을 요소 태그로 묶지 않습니다.\norder_by_clause 내에서 Oracle Database는 이 절의 다른 사용법과 달리 숫자 리터럴을 열 위치로 해석하지 않고 단순히 숫자 리터럴로 해석합니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":191,"id":2,"query":"SELECT XMLAgg(XMLElement(\"element\", column_name)) AS aggregated_xml FROM your_table WHERE condition;","exOrder":0}],"children":[]},{"id":192,"name":"XMLCOLATTVAL","description":"XMLCOLATTVAL(value_expr AS c_alias) 형식으로 사용합니다.\nXMLColAttVal 함수는 XML 단편을 생성한 다음 결과 XML을 확장하여 각 XML 단편이 속성 이름과 함께 name 컬럼을 갖도록 합니다. name 속성의 값을 컬럼 이름과 다른 값으로 변경하려면 AS c_alias 절을 사용할 수 있습니다.\nvalue_expr에 대한 값을 지정해야 합니다. 만약 value_expr이 null이라면 요소가 반환되지 않습니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":192,"id":2,"query":"SELECT XMLColAttVal(column_name, \u0027name\u0027, column_name) AS expanded_xml FROM your_table WHERE condition;","exOrder":0}],"children":[]},{"id":193,"name":"XMLCONCAT","description":"XMLCONCAT(XMLType_instance) 형식으로 사용합니다.\nXMLConcat 함수는 XMLType 인스턴스들의 시리즈를 입력으로 받아 각 행의 요소들을 연결하고 연결된 시리즈를 반환합니다. XMLConcat은 XMLSequence의 역입니다.\n결과에서 null 표현식은 제외됩니다. 만약 모든 값 표현식이 null이라면 함수는 null을 반환합니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":193,"id":2,"query":"SELECT XMLConcat(XMLType(\u0027\u003celement1\u003eValue1\u003c/element1\u003e\u0027), XMLType(\u0027\u003celement2\u003eValue2\u003c/element2\u003e\u0027)) AS concatenated_series FROM DUAL;","exOrder":0},{"fnId":193,"id":3,"query":"SELECT XMLConcat(XMLType(\u0027\u003celement1\u003eValue1\u003c/element1\u003e\u0027), NULL, XMLType(\u0027\u003celement2\u003eValue2\u003c/element2\u003e\u0027)) AS concatenated_series FROM DUAL;","exOrder":0}],"children":[]},{"id":194,"name":"XMLFOREST","description":"XMLFOREST(value_expr AS c_alias) 형식으로 사용합니다.\nXMLForest 함수는 각 인수 매개변수를 XML로 변환한 후, 이러한 변환된 인수들의 연결인 XML 단편을 반환합니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":194,"id":2,"query":"SELECT XMLForest(column1, column2, column3) AS xml_fragment FROM your_table WHERE condition;","exOrder":0}],"children":[]},{"id":159,"name":"DECODE","description":"DECODE(expr, search, result, default) 형식으로 사용합니다.\nDECODE 함수는 expr을 각각의 검색 값과 비교합니다. 만약 expr이 검색 값과 같다면, Oracle Database는 해당하는 결과를 반환합니다. 일치하는 값이 없으면 Oracle은 디폴트 값을 반환합니다. 만약 디폴트가 생략되었다면 Oracle은 null을 반환합니다.\n인수는 숫자 유형(NUMBER, BINARY_FLOAT 또는 BINARY_DOUBLE) 또는 문자 유형일 수 있습니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":159,"id":2,"query":"SELECT DECODE(expr, search1, result1, search2, result2, default) FROM DUAL;","exOrder":0}],"children":[]},{"id":160,"name":"DEPTH","description":"DEPTH(correlation_integer) 형식으로 사용합니다.\nDEPTH는 UNDER_PATH 및 EQUALS_PATH 조건과 함께만 사용되는 보조 함수입니다. 이 함수는 동일한 상관 변수로 지정된 UNDER_PATH 조건에 의해 지정된 경로의 레벨 수를 반환합니다.\ncorrelation_integer는 NUMBER 정수일 수 있습니다. 이 보조 함수를 주 조건과 연결하기 위해 사용합니다. 문장에 여러 개의 주 조건이 있는 경우 이를 상관시키는 데 사용됩니다. 1보다 작은 값은 1로 처리됩니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":160,"id":2,"query":"SELECT DEPTH(correlation_integer) FROM DUAL UNDER_PATH(\u0027path\u0027) WITHIN PATH;","exOrder":0}],"children":[]},{"id":161,"name":"DUMP","description":"DUMP(expr, return_fmt, start_position, length) 형식으로 사용합니다.\nDUMP 함수는 expr의 데이터 유형 코드, 바이트 단위의 길이, 그리고 내부 표현을 포함하는 VARCHAR2 값을 반환합니다. 반환된 결과는 항상 데이터베이스 문자 집합으로 표시됩니다.","itemType":"F","parentId":36,"examples":[{"fnId":161,"id":2,"query":"SELECT DUMP(\u0027abc\u0027, 1016) FROM DUAL;","exOrder":0},{"fnId":161,"id":3,"query":"SELECT DUMP(expr) FROM DUAL;","exOrder":0}],"children":[]},{"id":162,"name":"EMPTY_BLOB, EMPTY_CLOB","description":"EMPTY_BLOB와 EMPTY_CLOB은 LOB 변수를 초기화하거나 INSERT 또는 UPDATE 문에서 LOB 열 또는 속성을 EMPTY로 초기화하는 데 사용할 수 있는 빈 LOB 로케이터를 반환합니다. EMPTY는 LOB이 초기화되었지만 데이터로 채워지지 않은 상태를 의미합니다. 접근하고 데이터를 채우기 전에 개체 유형의 일부인 LOB 속성을 초기화해야 합니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":162,"id":2,"exOrder":0}],"children":[]},{"id":163,"name":"EXISTSNODE","description":"EXISTSNODE(XMLType_instance, XPath_string, namespace_string) 형식으로 사용합니다.\nEXISTSNODE 함수는 지정된 경로를 사용하여 XML 문서를 탐색할 때 결과적으로 노드가 있는지 여부를 결정합니다. 인수로는 XML 문서가 포함된 XMLType 인스턴스와 경로를 지정하는 VARCHAR2 XPath 문자열이 필요합니다. 선택적으로 사용하는 namespace_string은 Oracle Database가 XPath 식을 평가할 때 접두사에 대한 기본 매핑 또는 네임스페이스 매핑을 지정하는 VARCHAR2 값을 해결해야 합니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":163,"id":2,"query":"SELECT EXISTSNODE(xml_instance, \u0027xpath_string\u0027, \u0027namespace_string\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":164,"name":"EXTRACT(XML)","description":"EXTRACT(XMLType_instance, XPath_string, namespace_string) 형식으로 사용합니다.\nEXTRACT (XML) 함수는 EXISTSNODE 함수와 유사합니다. VARCHAR2 XPath 문자열을 적용하고 XML 단편을 포함하는 XMLType 인스턴스를 반환합니다. 선택적으로 사용하는 namespace_string은 Oracle Database가 XPath 식을 평가할 때 접두사에 대한 기본 매핑 또는 네임스페이스 매핑을 지정하는 VARCHAR2 값을 해결해야 합니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":164,"id":2,"query":"SELECT EXTRACT(xml_instance, \u0027xpath_string\u0027, \u0027namespace_string\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":165,"name":"EXTRACTVALUE","description":"EXTRACTVALUE(XMLType_instance, XPath_string, namespace_string) 형식으로 사용합니다.\nEXTRACTVALUE 함수는 XMLType 인스턴스와 XPath 식을 인수로 받아 결과 노드의 스칼라 값을 반환합니다. 결과는 단일 노드이어야 하며 텍스트 노드, 속성 또는 요소일 수 있습니다. 결과가 요소인 경우, 해당 요소는 자식으로 단일 텍스트 노드를 가져야 하며, 이 값이 함수가 반환하는 값입니다. 지정된 XPath가 하나 이상의 자식을 가진 노드를 가리키거나 가리키는 노드가 텍스트가 아닌 노드 자식을 가지고 있는 경우, Oracle은 오류를 반환합니다. 선택적으로 사용하는 namespace_string은 XPath 식을 평가할 때 접두사에 대한 기본 매핑 또는 네임스페이스 매핑을 지정하는 VARCHAR2 값을 해결해야 합니다.\nXML 스키마를 기반으로 한 문서의 경우, Oracle이 반환 값의 유형을 추론할 수 있는 경우, 해당 유형에 적합한 스칼라 값이 반환됩니다. 그렇지 않으면 결과는 VARCHAR2 유형입니다. XML 스키마를 기반으로하지 않는 문서의 경우, 반환 유형은 항상 VARCHAR2입니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":165,"id":2,"query":"SELECT EXTRACTVALUE(xml_instance, \u0027xpath_expression\u0027, \u0027namespace_string\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":166,"name":"GREATEST","description":"GREATEST(expr) 형식으로 사용합니다.\nGREATEST 함수는 하나 이상의 표현식 중 가장 큰 값을 반환합니다. Oracle Database는 반환 유형을 결정하기 위해 첫 번째 표현식을 사용합니다. 첫 번째 표현식이 숫자인 경우, Oracle은 가장 높은 숫자 우선 순위를 가진 인수를 결정하고, 비교 전에 나머지 인수를 해당 데이터 유형으로 암시적으로 변환한 후 해당 데이터 유형을 반환합니다. 첫 번째 표현식이 숫자가 아닌 경우, 첫 번째 이후의 각 표현식은 비교 전에 첫 번째 표현식의 데이터 유형으로 암시적으로 변환됩니다.\nOracle Database는 각 표현식을 패딩되지 않은 비교 의미론을 사용하여 비교합니다. 문자 비교는 데이터베이스 문자 집합의 문자 값에 기반합니다. 한 문자는 다른 문자보다 높은 문자 집합 값이 있다면 더 큽니다. 이 함수가 반환하는 값이 문자 데이터인 경우, 데이터 유형은 항상 VARCHAR2입니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":166,"id":2,"query":"SELECT GREATEST (\u0027HARRY\u0027, \u0027HARRIOT\u0027, \u0027HAROLD\u0027) \"Greatest\" FROM DUAL;","exOrder":0},{"fnId":166,"id":3,"query":"SELECT GREATEST(expr1, expr2, ...) FROM DUAL;","exOrder":0}],"children":[]},{"id":167,"name":"LEAST","description":"LEAST(expr) 형식으로 사용합니다.\nLEAST 함수는 exprs의 목록 중 가장 작은 값을 반환합니다. 첫 번째 expr 이후의 모든 expr은 비교 전에 첫 번째 expr의 데이터 유형으로 암시적으로 변환됩니다. Oracle Database는 expr을 패딩되지 않은 비교 의미론을 사용하여 비교합니다. 이 함수가 반환하는 값이 문자 데이터인 경우, 데이터 유형은 항상 VARCHAR2입니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":167,"id":2,"query":"SELECT LEAST(\u0027HARRY\u0027,\u0027HARRIOT\u0027,\u0027HAROLD\u0027) \"LEAST\" FROM DUAL;","exOrder":0},{"fnId":167,"id":3,"query":"SELECT LEAST(expr1, expr2, ...) FROM DUAL;","exOrder":0}],"children":[]},{"id":168,"name":"LNNVL","description":"LNNVL(condition) 형식으로 사용합니다.\nLNNVL 함수는 조건식의 한 쪽 또는 양쪽 피연산자 중 하나 이상이 null일 수 있는 상황에서 조건을 평가하는 간결한 방법을 제공합니다. 이 함수는 쿼리의 WHERE 절에서만 사용할 수 있습니다. 인수로 조건식을 받고, 조건이 FALSE 또는 UNKNOWN일 경우 TRUE를 반환하고, 조건이 TRUE인 경우 FALSE를 반환합니다. LNNVL은 스칼라 표현식이 사용될 수 있는 모든 위치에서 사용할 수 있으며, IS [NOT] NULL, AND, 또는 OR 조건이 유효하지 않은 경우에도 null 가능성을 처리해야 할 필요가 있는 문맥에서 사용될 수 있습니다. Oracle Database는 가끔 LNNVL 함수를 내부적으로 사용하여 NOT IN 조건을 NOT EXISTS 조건으로 다시 작성합니다. 이러한 경우에는 EXPLAIN PLAN의 출력에서 이 작업이 계획 테이블 출력에 나타납니다. 조건은 스칼라 값이 평가될 수 있지만 AND, OR, 또는 BETWEEN을 포함하는 복합 조건은 될 수 없습니다.","itemType":"F","parentId":36,"examples":[{"fnId":168,"id":2,"query":"SELECT * FROM DUAL WHERE LNNVL(condition);","exOrder":0},{"fnId":168,"id":3,"query":"SELECT COUNT(*) FROM employees WHERE LNNVL(commission_pct \u003e\u003d .2);","exOrder":0}],"children":[]},{"id":169,"name":"NLS_CHARSET_DECL_LEN","description":"LNNVL(condition) 형식으로 사용합니다.\nLNNVL 함수는 조건식의 한 쪽 또는 양쪽 피연산자 중 하나 이상이 null일 수 있는 상황에서 조건을 평가하는 간결한 방법을 제공합니다. 이 함수는 쿼리의 WHERE 절에서만 사용할 수 있습니다. 인수로 조건식을 받고, 조건이 FALSE 또는 UNKNOWN일 경우 TRUE를 반환하고, 조건이 TRUE인 경우 FALSE를 반환합니다. LNNVL은 스칼라 표현식이 사용될 수 있는 모든 위치에서 사용할 수 있으며, IS [NOT] NULL, AND, 또는 OR 조건이 유효하지 않은 경우에도 null 가능성을 처리해야 할 필요가 있는 문맥에서 사용될 수 있습니다. Oracle Database는 가끔 LNNVL 함수를 내부적으로 사용하여 NOT IN 조건을 NOT EXISTS 조건으로 다시 작성합니다. 이러한 경우에는 EXPLAIN PLAN의 출력에서 이 작업이 계획 테이블 출력에 나타납니다. 조건은 스칼라 값이 평가될 수 있지만 AND, OR, 또는 BETWEEN을 포함하는 복합 조건은 될 수 없습니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":169,"id":2,"query":"SELECT * FROM DUAL WHERE LNNVL(condition);","exOrder":0},{"fnId":169,"id":3,"query":"SELECT COUNT(*) FROM employees WHERE LNNVL(commission_pct \u003e\u003d .2);","exOrder":0}],"children":[]},{"id":172,"name":"NLS_CHARSET_NAME","description":"NLS_CHARSET_NAME(number) 형식으로 사용합니다.\nNLS_CHARSET_NAME 함수는 ID 번호에 해당하는 문자 집합의 이름을 반환합니다. 문자 집합 이름은 데이터베이스 문자 집합의 VARCHAR2 값으로 반환됩니다.\n만약 number가 유효한 문자 집합 ID로 인식되지 않는 경우, 이 함수는 null을 반환합니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":172,"id":2,"query":"SELECT NLS_CHARSET_NAME(2) FROM DUAL;","exOrder":0}],"children":[]},{"id":173,"name":"NULLIF","description":"NULLIF(expr1, expr2) 형식으로 사용합니다.\nNULLIF 함수는 expr1과 expr2를 비교합니다. 두 값이 동일하면 함수는 null을 반환합니다. 두 값이 동일하지 않으면 함수는 expr1을 반환합니다. expr1에는 리터럴 NULL을 지정할 수 없습니다.\n만약 두 인수가 숫자 데이터 유형이라면, Oracle Database는 숫자 우선순위가 더 높은 인수를 결정하고, 다른 인수를 해당 데이터 유형으로 암시적으로 변환한 후 그 데이터 유형을 반환합니다. 인수가 숫자가 아닌 경우, 동일한 데이터 유형이어야 하며, 그렇지 않으면 Oracle은 오류를 반환합니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":173,"id":2,"query":"SELECT NULLIF(expr1, expr2) FROM DUAL;","exOrder":0}],"children":[]},{"id":174,"name":"NVL","description":"NVL(expr1, expr2) 형식으로 사용합니다.\nNVL 함수는 쿼리 결과에서 null(공백으로 반환)을 지정한 문자열로 대체하는 데 사용됩니다. 만약 expr1이 null이라면, NVL은 expr2를 반환합니다. expr1이 null이 아니라면, NVL은 expr1을 반환합니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":174,"id":2,"query":"SELECT NVL(expr1, expr2) FROM DUAL;","exOrder":0}],"children":[]},{"id":175,"name":"NVL2","description":"NVL2(expr1, expr2, expr3) 형식으로 사용합니다.\nNVL2 함수는 지정한 표현식이 null인지 아닌지에 따라 쿼리에서 반환되는 값을 결정하는 데 사용됩니다. expr1이 null이 아니라면, NVL2는 expr2를 반환합니다. expr1이 null이라면, NVL2는 expr3을 반환합니다.\n인수 expr1은 어떤 데이터 타입이든 사용할 수 있습니다. 인수 expr2와 expr3은 LONG을 제외한 어떤 데이터 타입이든 사용할 수 있습니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":175,"id":2,"query":"SELECT NVL2(expr1, expr2, expr3) FROM DUAL;","exOrder":0}],"children":[]},{"id":176,"name":"ORA_HASH","description":"ORA_HASH(expr, max_bucket, seed_value) 형식으로 사용합니다.\nORA_HASH는 주어진 표현식에 대한 해시 값을 계산하는 함수입니다. 이 함수는 데이터의 일부를 분석하거나 무작위 샘플을 생성하는 등의 작업에 유용합니다.\nexpr 인수는 Oracle Database가 해시 값을 계산하기를 원하는 데이터를 지정합니다. expr에 의해 표시되는 데이터의 유형 또는 길이에는 제한이 없으며, 일반적으로 열 이름으로 해석됩니다.\n옵션인 max_bucket 인수는 해시 함수가 반환하는 최대 버킷 값입니다. 0부터 4294967295 사이의 값을 지정할 수 있습니다. 기본값은 4294967295입니다.\n옵션인 seed_value 인수는 Oracle이 동일한 데이터 집합에 대해 많은 다른 결과를 생성할 수 있도록 합니다. Oracle은 expr과 seed_value의 조합에 대해 해시 함수를 적용합니다. 0부터 4294967295 사이의 값을 지정할 수 있습니다. 기본값은 0입니다.\n이 함수는 NUMBER 값으로 반환됩니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":176,"id":2,"query":"SELECT ORA_HASH(expr, max_bucket, seed_value) FROM DUAL;","exOrder":0}],"children":[]},{"id":178,"name":"PATH","description":"PATH(correlation_integer) 형식으로 사용합니다.\nPATH는 UNDER_PATH 및 EQUALS_PATH 조건과 함께 사용되는 보조 함수입니다. 이 함수는 상위 조건에서 지정된 리소스로 이어지는 상대 경로를 반환합니다.\ncorrelation_integer은 NUMBER 정수로 사용할 수 있으며 이 보조 함수를 기본 조건과 연관시키는 데 사용됩니다. 1보다 작은 값은 1로 처리됩니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":178,"id":2,"query":"SELECT PATH(1) FROM dual;","exOrder":0}],"children":[]},{"id":179,"name":"SYS_CONNECT_BY_PATH","description":"SYS_CONNECT_BY_PATH(column, char) 형식으로 사용합니다.\nSYS_CONNECT_BY_PATH는 계층적 쿼리에서만 유효한 함수입니다. 이 함수는 CONNECT BY 조건에 따라 반환된 각 행의 열 값을 루트부터 노드까지의 경로로 반환하며, 열 값은 char로 구분됩니다.\n열과 char는 CHAR, VARCHAR2, NCHAR 또는 NVARCHAR2와 같은 데이터 유형 중 하나일 수 있습니다. 반환되는 문자열은 VARCHAR2 데이터 유형이며 열과 동일한 문자 집합을 가지고 있습니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":179,"id":2,"query":"SELECT SYS_CONNECT_BY_PATH(column, \u0027/\u0027) AS path FROM table START WITH parent_column IS NULL CONNECT BY PRIOR column \u003d parent_column;","exOrder":0}],"children":[]},{"id":180,"name":"SYS_CONTEXT","description":"SYS_CONTEXT(namespace, parameter, length) 형식으로 사용합니다.\nSYS_CONTEXT 함수는 컨텍스트 네임스페이스와 관련된 매개변수의 값을 반환합니다. 이 함수는 SQL 및 PL/SQL 문에서 모두 사용할 수 있습니다.\nnamespace와 parameter에는 문자열을 지정하거나 네임스페이스 또는 속성을 나타내는 문자열로 해석되는 식을 지정할 수 있습니다. 컨텍스트 네임스페이스는 이미 생성되어 있어야 하며, 연관된 매개변수와 해당 값은 DBMS_SESSION.set_context 프로시저를 사용하여 설정되어 있어야 합니다. 네임스페이스는 유효한 SQL 식별자여야 합니다. 매개변수 이름은 임의의 문자열일 수 있습니다. 대소문자를 구분하지 않지만 길이가 30바이트를 초과할 수 없습니다.\n반환 값의 데이터 유형은 VARCHAR2입니다. 반환 값의 기본 최대 크기는 256바이트입니다. 선택적인 length 매개변수를 지정하여 이 기본값을 재정의할 수 있습니다. length 매개변수는 NUMBER이거나 NUMBER로 암묵적으로 변환될 수 있는 값이어야 합니다. 유효한 값의 범위는 1에서 4000바이트까지입니다. 잘못된 값을 지정하면 Oracle Database가 무시하고 기본값을 사용합니다.\nOracle은 현재 세션을 설명하는 내장 네임스페이스인 USERENV를 제공합니다. USERENV 네임스페이스의 미리 정의된 매개변수는 테이블 7-11에 나열되어 있으며, 반환 문자열의 길이도 함께 제공됩니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":180,"id":2,"query":"SELECT SYS_CONTEXT (\u0027USERENV\u0027, \u0027SESSION_USER\u0027) FROM DUAL;","exOrder":0},{"fnId":180,"id":3,"query":"SELECT SYS_CONTEXT (\u0027hr_apps\u0027, \u0027group_no\u0027) \"User Group\" FROM DUAL;","exOrder":0},{"fnId":180,"id":4,"query":"SELECT SYS_CONTEXT(\u0027USERENV\u0027, \u0027SESSIONID\u0027) AS session_id FROM DUAL;","exOrder":0}],"children":[]},{"id":157,"name":"BFILENAME","description":"BFILENAME(directory, filename) 형식으로 사용합니다.\nBFILENAME는 서버 파일 시스템에 있는 실제 LOB 이진 파일과 연결된 BFILE 로케이터를 반환합니다.\n\u0027directory\u0027는 실제 파일이 위치한 서버 파일 시스템의 전체 경로 이름에 대한 별칭으로 사용되는 데이터베이스 개체입니다.\n\u0027filename\u0027은 서버 파일 시스템에서의 파일 이름입니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":157,"id":2,"query":"SELECT BFILENAME(\u0027directory\u0027, \u0027filename\u0027) FROM DUAL;","exOrder":0}],"children":[]},{"id":158,"name":"COALESCE","description":"COALESCE(expr) 형식으로 사용합니다.\nCOALESCE는 표현식 목록에서 첫 번째로 null이 아닌 expr을 반환합니다. 적어도 하나의 expr은 리터럴 NULL이 아니어야 합니다. 모든 expr이 null로 평가되면 함수는 null을 반환합니다.\n만약 모든 expr이 숫자 데이터 유형이거나 숫자 데이터 유형으로 암묵적으로 변환될 수 있는 비숫자 데이터 유형이라면, Oracle Database는 가장 높은 숫자 우선순위를 가진 인수를 결정하고, 나머지 인수를 해당 데이터 유형으로 암묵적으로 변환한 후 그 데이터 유형을 반환합니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":158,"id":2,"query":"SELECT COALESCE(expr1, expr2, expr3) FROM DUAL;","exOrder":0}],"children":[]},{"id":171,"name":"NLS_CHARSET_ID","description":"NLS_CHARSET_ID(text) 형식으로 사용합니다.\nNLS_CHARSET_ID 함수는 문자 집합 이름에 해당하는 문자 집합 ID 번호를 반환합니다. text 인수는 런타임 VARCHAR2 값입니다. text 값이 \u0027CHAR_CS\u0027인 경우 서버의 데이터베이스 문자 집합 ID 번호를 반환합니다. text 값이 \u0027NCHAR_CS\u0027인 경우 서버의 나라별 문자 집합 ID 번호를 반환합니다.\n유효하지 않은 문자 집합 이름은 null을 반환합니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":171,"id":2,"query":"SELECT NLS_CHARSET_ID(\u0027ja16euc\u0027) FROM DUAL;","exOrder":0},{"fnId":171,"id":3,"query":"SELECT NLS_CHARSET_ID(text) FROM DUAL;","exOrder":0}],"children":[]},{"id":181,"name":"SYS_DBURIGEN","description":"SYS_DBURIGEN(column/attribute, rowid, text) 형식으로 사용합니다.\nSYS_DBURIGEN 함수는 하나 이상의 열 또는 속성과 선택적으로 rowid를 인수로 받아 특정 열 또는 행 개체에 대한 DBURIType 데이터 유형의 URL을 생성합니다. 그런 다음 해당 URL을 사용하여 데이터베이스에서 XML 문서를 검색할 수 있습니다.\n참조하는 모든 열 또는 속성은 동일한 테이블에 있어야 합니다. 이들은 기본 키의 역할을 수행해야 합니다. 즉, 실제로 테이블의 기본 키와 일치할 필요는 없지만 고유한 값을 참조해야 합니다. 여러 열을 지정하는 경우, 마지막 열을 제외한 모든 열이 데이터베이스에서 행을 식별하고, 마지막으로 지정한 열이 행 내의 열을 식별합니다.\n기본적으로 URL은 서식이 있는 XML 문서를 가리킵니다. 문서의 텍스트만 가리키도록 URL을 지정하려면 선택적으로 \u0027text()\u0027를 지정하십시오. (이 XML 컨텍스트에서 소문자 text는 구문적인 플레이스홀더가 아닌 키워드입니다.)\n열 또는 속성을 포함하는 테이블 또는 뷰에 쿼리의 컨텍스트에서 스키마가 지정되지 않은 경우, Oracle Database는 테이블 또는 뷰 이름을 공용 동의어로 해석합니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":181,"id":2,"query":"SELECT SYS_DBURIGEN(column1, column2) AS url FROM table_name;","exOrder":0}],"children":[]},{"id":182,"name":"SYS_GUID","description":"SYS_GUID 함수는 16바이트로 구성된 전역 고유 식별자(RAW 값)를 생성하고 반환합니다. 대부분의 플랫폼에서 생성된 식별자는 호스트 식별자, 함수를 호출한 프로세스 또는 스레드의 프로세스 또는 스레드 식별자, 해당 프로세스 또는 스레드에 대한 반복되지 않는 값(바이트 시퀀스)으로 구성됩니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":182,"id":2,"query":"SELECT SYS_GUID() AS unique_id FROM DUAL;","exOrder":0}],"children":[]},{"id":195,"name":"XMLSEQUENCE","description":"XMLSEQUENCE(XMLType_instance/sys_refcursor_instance, fmt) 형식으로 사용합니다.\nXMLSequence 함수에는 두 가지 형태가 있습니다.\n첫 번째 형태는 XMLType 인스턴스를 입력으로 받고, 해당 XMLType의 최상위 노드를 가진 varray를 반환합니다.\n두 번째 형태는 REFCURSOR 인스턴스와 선택적으로 XMLFormat 객체의 인스턴스를 입력으로 받고, 커서의 각 행에 대해 XMLSequence 타입의 XML 문서를 반환합니다.\nXMLSequence는 XMLType의 컬렉션을 반환하기 때문에, 이 함수를 TABLE 절에서 사용하여 컬렉션 값을 여러 행으로 펼칠 수 있으며, 이후 SQL 쿼리에서 추가로 처리할 수 있습니다.\n","itemType":"F","parentId":36,"examples":[{"fnId":195,"id":2,"query":"SELECT column_value FROM TABLE(XMLSequence(XMLType(\u0027\u003croot\u003e\u003celement1\u003eValue1\u003c/element1\u003e\u003celement2\u003eValue2\u003c/element2\u003e\u003c/root\u003e\u0027))) x","exOrder":0}],"children":[]},{"id":196,"name":"XMLTRANSFORM","description":"XMLTRANSFORM(XMLType_instance, XMLType_instance) 형식으로 사용합니다.\nXMLTransform 함수는 XMLType 인스턴스와 XSL 스타일 시트(XMLType 인스턴스의 형태)를 인수로 받습니다. 이 함수는 스타일 시트를 인스턴스에 적용하고 XMLType을 반환합니다.\n이 함수는 데이터베이스에서 데이터를 검색하는 동안 스타일 시트에 따라 데이터를 구성하는 데 유용합니다.","itemType":"F","parentId":36,"examples":[{"fnId":196,"id":2,"exOrder":0}],"children":[]}]},{"id":35,"name":"모델 함수(Model Functions)","description":"인접행 간의 계산에만 사용되며 SELECT문의 model 절에서만 사용됩니다. 재귀적이지 않습니다.","itemType":"C","parentId":8,"children":[{"id":152,"name":"CV","description":"CV(dimension_column) 형식으로 사용합니다.\nCV 함수는 인터로우 계산에만 관련이 있습니다. 이 함수는 SELECT 문의 model_clause에서만 사용할 수 있으며, 오직 모델 규칙의 오른쪽에 위치한 경우에만 사용할 수 있습니다. CV 함수는 모델 규칙의 왼쪽에서 오른쪽으로 전달된 차원 열의 현재 값을 반환합니다. 이 함수는 model_clause에서 차원 열에 대한 상대적인 인덱싱을 제공하기 위해 사용됩니다. 반환되는 데이터 타입은 차원 열의 데이터 타입과 동일합니다. 인수를 생략하면 함수가 셀 참조 내에서의 상대적인 위치에 연결된 차원 열을 기본값으로 사용합니다.\n","itemType":"F","parentId":35,"examples":[{"fnId":152,"id":2,"query":"SELECT CV(dimension_column) FROM your_table MODEL RETURN UPDATED ROWS DIMENSION BY (dimension_column) MEASURES (measure_column) RULES UPSERT SEQUENTIAL ORDER (measure_column[ANY] \u003d CV(dimension_column) + 1);","exOrder":0}],"children":[]},{"id":153,"name":"ITERATION_NUMBER","description":"PRESENTNNV(cell_reference, expr1, expr2) 형식으로 사용합니다.\nPRESENTNNV 함수는 인터로우 계산에만 관련이 있습니다. 이 함수는 SELECT 문의 model_clause에서만 사용할 수 있으며, model_rules_clause의 오른쪽에만 사용할 수 있습니다. 이 함수는 model_clause의 실행 이전에 cell_reference가 존재하고 null이 아닌 경우 expr1을 반환합니다. 그렇지 않으면 expr2를 반환합니다.\n","itemType":"F","parentId":35,"examples":[{"fnId":153,"id":2,"query":"SELECT PRESENTNNV(cell_reference, expr1, expr2) FROM your_table MODEL RETURN UPDATED ROWS DIMENSION BY (dimension_column) MEASURES (measure_column) RULES (measure_column[ANY] \u003d PRESENTNNV(cell_reference, 1, 0));","exOrder":0}],"children":[]},{"id":154,"name":"PRESENTNNV","description":"PRESENTNNV(cell_reference, expr1, expr2) 형식으로 사용합니다.\nPRESENTNNV 함수는 인터로우 계산에만 관련이 있습니다. 이 함수는 SELECT 문의 model_clause에서만 사용할 수 있으며, model_rules_clause의 오른쪽에만 사용할 수 있습니다. 이 함수는 model_clause의 실행 이전에 cell_reference가 존재하고 null이 아닌 경우 expr1을 반환합니다. 그렇지 않으면 expr2를 반환합니다.\n","itemType":"F","parentId":35,"examples":[{"fnId":154,"id":2,"query":"SELECT PRESENTNNV(cell_reference, expr1, expr2) FROM your_table MODEL RETURN UPDATED ROWS DIMENSION BY (dimension_column) MEASURES (measure_column) RULES (measure_column[ANY] \u003d PRESENTNNV(cell_reference, 1, 0));","exOrder":0}],"children":[]},{"id":155,"name":"PRESENTV","description":"PRESENTV(cell_reference, expr1, expr2) 형식으로 사용합니다.\nPRESENTV 함수는 인터로우 계산에만 관련이 있습니다. 이 함수는 SELECT 문의 model_clause 내에서만 사용할 수 있으며, model_clause의 오른쪽에만 사용할 수 있습니다. 이 함수는 model_clause 실행 전에 cell_reference가 존재할 경우 expr1을 반환하고, 그렇지 않을 경우 expr2를 반환합니다.\n","itemType":"F","parentId":35,"examples":[{"fnId":155,"id":2,"query":"SELECT PRESENTV(cell_reference, expr1, expr2) FROM your_table MODEL RETURN UPDATED ROWS DIMENSION BY (dimension_column) MEASURES (measure_column) RULES (measure_column[ANY] \u003d PRESENTV(cell_reference, 1, 0));","exOrder":0}],"children":[]},{"id":156,"name":"PREVIOUS","description":"PREVIOUS(cell_reference) 형식으로 사용합니다.\nPREVIOUS 함수는 인터로우 계산에만 관련이 있습니다. 이 함수는 SELECT 문의 model_clause 내에서만 사용할 수 있으며, model_rules_clause의 ITERATE ... [UNTIL] 절에서만 사용할 수 있습니다. 이 함수는 각 반복의 시작 시점에서 cell_reference의 값을 반환합니다.\n","itemType":"F","parentId":35,"examples":[{"fnId":156,"id":2,"query":"SELECT PREVIOUS(cell_reference) FROM your_table MODEL ITERATE (expr UNTIL condition) RETURN UPDATED ROWS DIMENSION BY (dimension_column) MEASURES (measure_column) RULES (measure_column[ANY] \u003d PREVIOUS(cell_reference));","exOrder":0}],"children":[]}]}]},{"id":9,"name":"다중행 함수(Multi-Row-Function)","description":"다중행 함수는 집계함수, 그룹함수, 윈도우 함수로 구분된다.","itemType":"C","parentId":1,"children":[{"id":32,"name":"집계 함수(Aggregate Functions)","description":"집계 함수는 단일 행이 아닌 행 그룹을 기반으로 한 개의 결과 행을 반환합니다.\n일반적으로 SELECT문의 GROUB BY 절에서 사용되며, GROUB BY 절을 생략하면 오라클은 질의된 테이블이나 뷰의 모든 행에 대해 집계 함수를 적용합니다.\n집계 함수는 SELECT, ORDER BY, HAVING 절에서도 사용할 수 있습니다.","itemType":"C","parentId":9,"children":[{"id":249,"name":"STDDEV_SAMP","description":"STDDEV_SAMP(expr) OVER(analytic_clause) 형식으로 사용합니다.\nSTDDEV_SAMP 함수는 누적 표본 표준 편차를 계산하고 표본 분산의 제곱근을 반환합니다. 이 함수는 집계 및 분석 함수로 사용할 수 있습니다.\n이 함수는 숫자 유형 또는 숫자 유형으로 암묵적으로 변환될 수 있는 비숫자 유형을 인수로 사용합니다. 함수는 인수의 숫자 유형과 동일한 데이터 유형을 반환합니다.","itemType":"F","parentId":32,"examples":[{"fnId":249,"id":2,"query":"SELECT STDDEV_SAMP(column_name) AS std_dev_samp FROM your_table;","exOrder":0}],"children":[]},{"id":202,"name":"AVG","description":"AVG(DISTINC/ALL expr) OVER(analytic_clause) 형식으로 사용합니다.\nAVG 함수는 expr의 평균 값을 반환합니다.\n이 함수는 숫자 데이터 유형 또는 숫자 데이터 유형으로 암시적으로 변환될 수 있는 비숫자 데이터 유형을 인수로 받습니다. 함수는 인수의 숫자 데이터 유형과 동일한 데이터 유형을 반환합니다.\n","itemType":"F","parentId":32,"examples":[{"fnId":202,"id":2,"query":"SELECT AVG(numeric_column) AS average_value FROM your_table;","exOrder":0}],"children":[]},{"id":203,"name":"CORR","description":"CORR(expr1, expr2) OVER(analytic_clause) 형식으로 사용합니다.\nCORR 함수는 숫자 쌍의 집합의 상관 계수를 반환합니다. 이 함수는 집계 함수나 분석 함수로 사용할 수 있습니다.\n이 함수는 숫자 데이터 타입이나 숫자 데이터 타입으로 암시적으로 변환될 수 있는 비숫자 데이터 타입을 인수로 받습니다. Oracle은 가장 높은 숫자 우선순위를 갖는 인수를 결정하고, 나머지 인수를 해당 데이터 타입으로 암시적으로 변환한 후 해당 데이터 타입을 반환합니다.\n","itemType":"F","parentId":32,"examples":[{"fnId":203,"id":2,"query":"SELECT CORR(numeric_column1, numeric_column2) AS correlation_coefficient FROM your_table;","exOrder":0}],"children":[]},{"id":204,"name":"CORR_*","description":"CORR_*(expr1, expr2, CONFFICIENT, ONE_SIDED_SIG, TWO_SIDED_SIG) 형식으로 사용합니다.\nCORR 함수는 피어슨 상관 계수(Pearson\u0027s correlation coefficient)를 계산하며, 입력으로는 숫자 표현식이 필요합니다. CORR_* 함수는 비모수적 또는 순위 상관관계를 지원합니다. 이 함수들은 값의 순위를 할 수 있는 순서 척도(ordinal scaled)에서 표현식 간의 상관관계를 찾을 수 있습니다. 상관 계수는 -1에서 1까지의 값을 가지며, 1은 완벽한 양의 상관관계를 나타내고, -1은 완벽한 음의 상관관계를 나타냅니다(하나의 변수가 증가하면 다른 변수가 감소함). 0에 가까운 값은 상관관계가 없음을 의미합니다.\n이 함수들은 숫자 데이터 유형이나 숫자 데이터 유형으로 암시적으로 변환될 수 있는 비숫자 데이터 유형을 인수로 받습니다. Oracle 데이터베이스는 가장 높은 숫자 우선순위를 가진 인수를 결정하고, 나머지 인수를 해당 데이터 유형으로 암시적으로 변환한 후 계산을 수행하며, 결과로 NUMBER 데이터 유형을 반환합니다.\n","itemType":"C","parentId":32,"children":[{"id":205,"name":"CORR_S","description":"CORR_S 함수는 스피어만의 순위 상관계수(Spearman\u0027s rho correlation coefficient)를 계산합니다. 입력 표현식은 (xi, yi) 쌍의 관측값 집합이어야 합니다. 이 함수는 먼저 각 값에 대해 순위를 할당합니다. 각 xi의 값은 샘플 내의 다른 모든 xi 값 중에서의 순위로 대체되고, 각 yi의 값은 샘플 내의 다른 모든 yi 값 중에서의 순위로 대체됩니다. 따라서 각 xi와 yi는 1부터 n까지의 값을 가지며, 여기서 n은 값 쌍의 총 개수입니다. 동점인 경우, 값이 약간 다른 경우에 해당 값들이 가질 순위의 평균으로 할당됩니다. 그런 다음 함수는 순위의 선형 상관계수를 계산합니다.\n","itemType":"F","parentId":204,"examples":[{"fnId":205,"id":2,"query":"SELECT CORR_S(xi, yi) AS correlation_coefficient FROM your_table;","exOrder":0}],"children":[]},{"id":206,"name":"CORR_K","description":"CORR_K 함수는 켄달의 타우-b(Kendall\u0027s tau-b) 상관계수를 계산합니다. CORR_S와 마찬가지로 입력 표현식은 (xi, yi) 쌍의 관측값 집합입니다. 상관계수를 계산하기 위해 함수는 일치하는 쌍과 불일치하는 쌍의 개수를 세어야 합니다. 관측값 쌍이 일치하는 경우는 더 큰 x값을 가진 관측값이 더 큰 y값을 가지는 경우입니다. 관측값 쌍이 불일치하는 경우는 더 큰 x값을 가진 관측값이 더 작은 y값을 가지는 경우입니다.\ntau-b의 유의성은 tau-b에 의해 나타나는 상관계수가 우연에 의한 것인 확률을 나타냅니다. 이는 0부터 1까지의 값으로 표현됩니다. tau-b의 값이 양수인 경우에는 유의한 상관관계를 나타내며(음수인 경우는 상반된 상관관계), 값이 작을수록 상관관계가 유의미합니다.\n","itemType":"F","parentId":204,"examples":[{"fnId":206,"id":2,"query":"SELECT CORR_K(xi, yi) AS correlation_coefficient FROM your_table;","exOrder":0}],"children":[]}]},{"id":207,"name":"COUNT","description":"COUNT(DISTINC/ALL expr) OVER(analytic_clause) 형식으로 사용합니다.\nCOUNT 함수는 쿼리에 의해 반환된 행의 개수를 반환합니다. 이 함수는 집계 함수나 분석 함수로 사용할 수 있습니다.\nDISTINCT를 지정하면 analytic_clause의 query_partition_clause만 지정할 수 있습니다. order_by_clause와 windowing_clause는 허용되지 않습니다.\nexpr을 지정하면 COUNT는 expr이 null이 아닌 행의 개수를 반환합니다. 모든 행 또는 expr의 고유한 값만을 카운트할 수 있습니다.\n별표(*)를 지정하면 이 함수는 중복 및 null을 포함한 모든 행을 반환합니다. COUNT는 결코 null을 반환하지 않습니다.\n","itemType":"F","parentId":32,"examples":[{"fnId":207,"id":2,"query":"SELECT COUNT(*) \"Total\" FROM employees;","exOrder":0}],"children":[]},{"id":208,"name":"COVAR_POP","description":"COVAR_POP(expr1, expr2) OVER(analytic_clause) 형식으로 사용합니다.\nCOVAR_POP 함수는 숫자 쌍의 모집단 공분산을 반환합니다. 이 함수는 집계 함수나 분석 함수로 사용할 수 있습니다.\n이 함수는 숫자 데이터 타입이나 숫자 데이터 타입으로 암시적으로 변환될 수 있는 비숫자 데이터 타입을 인수로 받습니다. Oracle은 가장 높은 숫자 우선순위를 갖는 인수를 결정하고, 나머지 인수를 해당 데이터 타입으로 암시적으로 변환한 후 해당 데이터 타입을 반환합니다.\n","itemType":"F","parentId":32,"examples":[{"fnId":208,"id":2,"query":"SELECT COVAR_POP(numeric_column1, numeric_column2) AS population_covariance FROM your_table;","exOrder":0}],"children":[]},{"id":209,"name":"COVAR_SAMP","description":"COVAR_SAMP(expr1, expr2) OVER(analytic_clause) 형식으로 사용합니다.\nCOVAR_SAMP 함수는 숫자 쌍의 표본 공분산을 반환합니다. 이 함수는 집계 함수나 분석 함수로 사용할 수 있습니다.\n이 함수는 숫자 데이터 타입이나 숫자 데이터 타입으로 암시적으로 변환될 수 있는 비숫자 데이터 타입을 인수로 받습니다. Oracle은 가장 높은 숫자 우선순위를 갖는 인수를 결정하고, 나머지 인수를 해당 데이터 타입으로 암시적으로 변환한 후 해당 데이터 타입을 반환합니다.\n","itemType":"F","parentId":32,"examples":[{"fnId":209,"id":2,"query":"SELECT COVAR_SAMP(numeric_column1, numeric_column2) AS sample_covariance FROM your_table;","exOrder":0}],"children":[]},{"id":210,"name":"CUME_DIST","description":"집계할 때는 CUME_DIST(expr) WITHIN GROUP 형식으로 사용합니다.\n분석할 때는 CUME_DIST() OVER(query_partition_clause order_by_clause) 형식으로 사용합니다.\nCUME_DIST 함수는 값 그룹에서 주어진 값의 누적 분포를 계산합니다. CUME_DIST가 반환하는 값의 범위는 \u003e0에서 \u003c\u003d1입니다. 동일한 값을 가지는 경우 항상 동일한 누적 분포 값을 가집니다.\n이 함수는 숫자 데이터 타입이나 숫자 데이터 타입으로 암시적으로 변환될 수 있는 비숫자 데이터 타입을 인수로 받습니다. Oracle Database는 가장 높은 숫자 우선순위를 갖는 인수를 결정하고, 나머지 인수를 해당 데이터 타입으로 암시적으로 변환한 후 해당 데이터 타입을 반환합니다.\n","itemType":"F","parentId":32,"examples":[{"fnId":210,"id":2,"query":"SELECT CUME_DIST(numeric_column) AS cumulative_distribution FROM your_table;","exOrder":0}],"children":[]},{"id":211,"name":"DENSE_RANK","description":"집계할 때는 DENSE_RANK(expr) WITHIN GROUP 형식으로 사용합니다.\n분석할 때는 DENSE_RANK() OVER(query_partition_clause order_by_clause) 형식으로 사용합니다.\nDENSE_RANK 함수는 정렬된 행 그룹에서 행의 순위를 계산하고 순위를 NUMBER로 반환합니다. 순위는 1부터 시작하는 연속적인 정수입니다. 가장 큰 순위 값은 쿼리에 의해 반환된 고유한 값의 수입니다. 동점이 있는 경우 순위 값은 건너뛰지 않습니다. 순위 기준에 대해 동일한 값을 가진 행은 동일한 순위를 받습니다. 이 함수는 상위 N개 또는 하위 N개의 보고서 작성에 유용합니다.\n","itemType":"F","parentId":32,"examples":[{"fnId":211,"id":2,"query":"SELECT DENSE_RANK() OVER (ORDER BY column1) AS dense_rank FROM your_table;","exOrder":0}],"children":[]},{"id":212,"name":"FIRST","description":"FIRST와 LAST는 매우 유사한 함수입니다. 두 함수 모두 주어진 정렬 기준에 따라 FIRST 또는 LAST로 순위가 매겨진 행 집합에서 값의 집합에 대해 동작하는 집계 및 분석 함수입니다. FIRST 또는 LAST로 순위가 매겨진 행이 하나만 있는 경우, 집계는 하나의 요소로 이루어진 집합에서 동작합니다.\n이 함수는 숫자 데이터 타입이나 숫자 데이터 타입으로 암시적으로 변환될 수 있는 비숫자 데이터 타입을 인수로 받습니다. 함수는 인수의 숫자 데이터 타입과 동일한 데이터 타입을 반환합니다.\n정렬된 그룹의 첫 번째 또는 마지막 행에서 필요한 값을 가져와야 하지만 필요한 값이 정렬 키가 아닌 경우, FIRST와 LAST 함수는 자체 조인 또는 뷰의 필요성을 제거하고 성능을 향상시킵니다.\n","itemType":"F","parentId":32,"examples":[{"fnId":212,"id":2,"exOrder":0}],"children":[]},{"id":213,"name":"GROUP_ID","description":"GROUP_ID는 GROUP BY 구문에서 발생하는 중복 그룹을 구별합니다. 쿼리 결과에서 중복 그룹을 필터링하는 데 유용합니다. 이 함수는 GROUP BY 절이 포함된 SELECT 문에서만 사용할 수 있습니다. GROUP_ID는 중복 그룹을 고유하게 식별하기 위해 Oracle NUMBER를 반환합니다.\n특정 그룹에 n개의 중복이 존재하는 경우, GROUP_ID는 0부터 n-1까지의 숫자를 반환합니다.\n","itemType":"F","parentId":32,"examples":[{"fnId":213,"id":2,"exOrder":0}],"children":[]},{"id":215,"name":"GROUPING_ID","description":"GROUPING_ID(expr) 형식으로 사용합니다.\nGROUPING_ID 함수는 행과 관련된 GROUPING 비트 벡터에 해당하는 숫자를 반환합니다. GROUPING_ID 함수는 ROLLUP 또는 CUBE와 같은 GROUP BY 확장 구문 및 GROUPING 함수가 포함된 SELECT 문에서만 사용할 수 있습니다. 많은 GROUP BY 표현식이 있는 쿼리에서 특정 행의 GROUP BY 레벨을 결정하는 것은 많은 GROUPING 함수가 필요하여 번거로운 SQL을 초래합니다. GROUPING_ID는 이러한 경우에 유용합니다.\n","itemType":"F","parentId":32,"examples":[{"fnId":215,"id":2,"query":"SELECT column1, column2, GROUPING_ID() AS grouping_id FROM your_table GROUP BY ROLLUP(column1, column2);","exOrder":0}],"children":[]},{"id":216,"name":"LAST","description":"FIRST와 LAST는 매우 유사한 함수입니다. 두 함수 모두 주어진 정렬 기준에 따라 FIRST 또는 LAST로 순위가 매겨진 행들의 값 집합에 대해 작동하는 집계 및 분석 함수입니다. FIRST 또는 LAST로 순위가 매겨진 행이 하나만 있는 경우, 집계 함수는 해당 행 하나만을 대상으로 작동합니다.\n이 함수는 숫자 데이터 타입이거나 숫자 데이터 타입으로 암시적으로 변환될 수 있는 비숫자 데이터 타입을 인수로 받습니다. 함수는 인수의 숫자 데이터 타입과 동일한 데이터 타입을 반환합니다.\n","itemType":"F","parentId":32,"examples":[{"fnId":216,"id":2,"query":"SELECT FIRST(numeric_column) AS first_value, LAST(numeric_column) AS last_value FROM your_table;","exOrder":0}],"children":[]},{"id":217,"name":"MAX","description":"MAX(DISTINC/ALL expr) OVER(analytic_clause) 형식으로 사용합니다.\nMAX 함수는 expr의 최댓값을 반환합니다. 이 함수는 집계 함수나 분석 함수로 사용할 수 있습니다.\n만약 DISTINCT를 지정하면, analytic_clause의 query_partition_clause만 지정할 수 있습니다. order_by_clause와 windowing_clause는 허용되지 않습니다.\n","itemType":"F","parentId":32,"examples":[{"fnId":217,"id":2,"query":"SELECT MAX(numeric_column) AS max_value FROM your_table;","exOrder":0},{"fnId":217,"id":3,"query":"SELECT column1, column2, MAX(numeric_column) OVER (PARTITION BY column1, column2) AS max_value FROM your_table;","exOrder":0}],"children":[]},{"id":218,"name":"MEDIAN","description":"MEDIAN(expr) OVER(query_partition_clause) 형식으로 사용합니다.\nMEDIAN은 연속적인 분포 모델을 가정하는 역분포 함수입니다. 숫자나 날짜/시간 값이 주어지면 해당 값들을 정렬한 후 중간값 또는 중간값으로 적용될 보간값을 반환합니다. 계산 과정에서 null 값은 무시됩니다.\n이 함수는 숫자 데이터 유형이나 숫자 데이터 유형으로 암묵적으로 변환할 수 있는 비숫자 데이터 유형을 인수로 받습니다. expr만 지정한 경우, 함수는 인수의 숫자 데이터 유형과 동일한 데이터 유형을 반환합니다. OVER 절을 지정한 경우, Oracle Database는 인수 중에서 가장 높은 숫자 우선순위를 가진 인수를 결정하고, 나머지 인수를 해당 데이터 유형으로 암묵적으로 변환한 후 해당 데이터 유형을 반환합니다.\n","itemType":"F","parentId":32,"examples":[{"fnId":218,"id":2,"query":"SELECT column1, column2, MEDIAN(numeric_column) OVER (PARTITION BY column1, column2) AS median_value FROM your_table;","exOrder":0}],"children":[]},{"id":219,"name":"MIN","description":"MIN(DISTINC/ALL expr) OVER(analytic_clause) 형식으로 사용합니다.\nMIN은 expr의 최소값을 반환합니다. 이 함수는 집계 함수 또는 분석 함수로 사용할 수 있습니다.\n만약 DISTINCT를 지정하면, analytic_clause의 order_by_clause와 windowing_clause를 사용할 수 없고, query_partition_clause만 사용할 수 있습니다.\n","itemType":"F","parentId":32,"examples":[{"fnId":219,"id":2,"query":"SELECT column1, column2, MIN(numeric_column) OVER (PARTITION BY column1, column2) AS min_value FROM your_table;","exOrder":0},{"fnId":219,"id":3,"query":"SELECT MIN(DISTINCT numeric_column) AS min_value FROM your_table;","exOrder":0}],"children":[]},{"id":220,"name":"PERCENTILE_CONT","description":"PERCENTILE_CONT(expr) WITHIN GROUP(ORDER BY expr ASC/DESC) OVER(query_partition_clause) 형식으로 사용합니다.\nPERCENTILE_CONT는 연속적인 분포 모델을 가정하는 역분포 함수입니다. 백분위 값과 정렬 기준을 입력받아, 해당 백분위 값에 해당하는 보간된 값을 반환합니다. 계산 시 NULL 값은 무시됩니다.\n이 함수는 숫자 데이터 타입 또는 숫자 데이터 타입으로 암묵적으로 변환 가능한 비숫자 데이터 타입을 인수로 사용합니다. 함수는 인수의 숫자 데이터 타입과 동일한 데이터 타입을 반환합니다.\n","itemType":"F","parentId":32,"examples":[{"fnId":220,"id":2,"query":"SELECT PERCENTILE_CONT(0.5) WITHIN GROUP (ORDER BY numeric_column) AS percentile_value FROM your_table;","exOrder":0}],"children":[]},{"id":221,"name":"PERCENTILE_DISC","description":"PERCENTILE_DISC(expr) WITHIN GROUP(ORDER BY expr ASC/DESC) OVER(query_partition_clause) 형식으로 사용합니다.\nPERCENTILE_DISC는 이산적인 분포 모델을 가정하는 역분포 함수입니다. 백분위 값과 정렬 기준을 입력받아 집합에서 요소를 반환합니다. 계산 시 NULL 값은 무시됩니다.\n이 함수는 숫자 데이터 타입이나 숫자 데이터 타입으로 암묵적으로 변환 가능한 비숫자 데이터 타입을 인수로 사용합니다. 함수는 인수의 숫자 데이터 타입과 동일한 데이터 타입을 반환합니다.\n","itemType":"F","parentId":32,"examples":[{"fnId":221,"id":2,"query":"SELECT PERCENTILE_DISC(0.5) WITHIN GROUP (ORDER BY numeric_column) AS percentile_value FROM your_table;","exOrder":0}],"children":[]},{"id":222,"name":"PERCENT_RANK","description":"집계할 때는 PERCENT_RANK(expr) WITHIN GROUP(ORDER BY expr ASC/DESC NULLS FIRST/LAST) 형식으로 사용합니다.\n분석할 때는 PERCENT_RANK() OVER(query_partition_clause order_by_clause) 형식으로 사용합니다.\nPERCENT_RANK 함수는 CUME_DIST (누적 분포) 함수와 유사합니다. PERCENT_RANK 함수의 반환 값 범위는 0부터 1까지(포함)입니다. 어떤 집합에서 첫 번째 행의 PERCENT_RANK는 0입니다. 반환 값은 NUMBER 데이터 타입입니다.\n","itemType":"F","parentId":32,"examples":[{"fnId":222,"id":2,"query":"SELECT PERCENT_RANK() WITHIN GROUP (ORDER BY numeric_column) AS percent_rank_value FROM your_table;","exOrder":0}],"children":[]},{"id":223,"name":"RANK","description":"집계할 때는 RANK(expr) WITHIN GROUP (ORDER BY expr DESC/ASC NULLS FIRST/LAST) 형식으로 사용합니다.\n분석할 때는 RANK() OVER (query_partition_clause order_by_clause) 형식으로 사용합니다.\nRANK 함수는 값의 순위를 계산하는 함수입니다. 반환 타입은 NUMBER입니다.\n","itemType":"F","parentId":32,"examples":[{"fnId":223,"id":2,"query":"SELECT RANK() OVER (ORDER BY numeric_column) AS rank_value FROM your_table;","exOrder":0}],"children":[]},{"id":224,"name":"선형 회귀 함수(REGR_ (Linear Regression) Functions)","description":"선형 회귀 함수로는 REGR_SLOPE, REGR_INTERCEPT, REGR_COUNT, REGR_R2, REGR_AVGX, REGR_AVGY, REGR_SXX, REGR_SYY, REGR_SXY 가 있습니다.\n함수(expr1, expr2) OVER(analytic_clause) 형식으로 사용합니다.\n\n선형 회귀 함수는 숫자 쌍의 집합에 최소제곱법 회귀선을 적합시킵니다. 이 함수는 집계 및 분석 함수로 사용할 수 있습니다.","itemType":"C","parentId":32,"children":[{"id":225,"name":"REGR_SLOPE","description":"REGR_SLOPE 함수는 선의 기울기를 반환합니다. 반환 값은 숫자 데이터 유형이며 null일 수 있습니다. null (expr1, expr2) 쌍이 제거된 후 다음 계산을 수행합니다:\n\nCOVAR_POP(expr1, expr2) / VAR_POP(expr2)","itemType":"F","parentId":224,"examples":[{"fnId":225,"id":2,"exOrder":0}],"children":[]},{"id":226,"name":"REGR_INTERCEPT ","description":"REGR_INTERCEPT 함수는 회귀선의 y-절편을 반환합니다. 반환 값은 숫자 데이터 유형이며 null일 수 있습니다. null (expr1, expr2) 쌍이 제거된 후 다음 계산을 수행합니다:\n\nAVG(expr1) - REGR_SLOPE(expr1, expr2) * AVG(expr2)","itemType":"F","parentId":224,"examples":[{"fnId":226,"id":2,"exOrder":0}],"children":[]},{"id":227,"name":"REGR_COUNT","description":"REGR_COUNT 함수는 회귀선을 적합시키는 데 사용된 null이 아닌 숫자 쌍의 개수를 나타내는 정수를 반환합니다.","itemType":"F","parentId":224,"examples":[{"fnId":227,"id":2,"exOrder":0}],"children":[]},{"id":228,"name":"REGR_R2","description":"REGR_R2 함수는 회귀분석의 결정 계수(R-제곱 또는 적합도)를 반환합니다. 반환 값은 숫자 데이터 유형이며 null일 수 있습니다. VAR_POP(expr1) 및 VAR_POP(expr2)는 null 쌍이 제거된 후에 계산됩니다. 반환 값은 다음과 같습니다:\nVAR_POP(expr2) \u003d 0인 경우 NULL\nVAR_POP(expr1) \u003d 0이고 VAR_POP(expr2) ≠ 0인 경우 1\nVAR_POP(expr1) \u003e 0이고 VAR_POP(expr2) ≠ 0인 경우 CORR(expr1, expr2)의 제곱인 POWER(CORR(expr1, expr2), 2)","itemType":"F","parentId":224,"examples":[{"fnId":228,"id":2,"exOrder":0}],"children":[]},{"id":229,"name":"REGR_AVGX ","description":"REGR_AVGX 함수는 회귀선의 독립 변수(expr2)의 평균을 계산합니다. null (expr1, expr2) 쌍이 제거된 후 다음 계산을 수행합니다:\n\nAVG(expr2)","itemType":"F","parentId":224,"examples":[{"fnId":229,"id":2,"exOrder":0}],"children":[]},{"id":230,"name":"REGR_AVGY","description":"REGR_AVGY 함수는 회귀선의 종속 변수(expr1)의 평균을 계산합니다. null (expr1, expr2) 쌍이 제거된 후 다음 계산을 수행합니다:\n\nAVG(expr1)","itemType":"F","parentId":224,"examples":[{"fnId":230,"id":2,"exOrder":0}],"children":[]},{"id":231,"name":"REGR_SXX","description":"REGR_SXX 함수는 null (expr1, expr2) 쌍이 제거된 후 다음 계산을 수행합니다:\n\nREGR_COUNT(expr1, expr2) * VAR_POP(expr2)","itemType":"F","parentId":224,"examples":[{"fnId":231,"id":2,"exOrder":0}],"children":[]},{"id":233,"name":"REGR_SXY","description":"REGR_SXY 함수는 null (expr1, expr2) 쌍이 제거된 후 다음 계산을 수행합니다:\n\nREGR_COUNT(expr1, expr2) * COVAR_POP(expr1, expr2)","itemType":"F","parentId":224,"examples":[{"fnId":233,"id":2,"exOrder":0}],"children":[]},{"id":232,"name":"REGR_SYY","description":"REGR_SYY 함수는 null (expr1, expr2) 쌍이 제거된 후 다음 계산을 수행합니다:\n\nREGR_COUNT(expr1, expr2) * VAR_POP(expr1)","itemType":"F","parentId":224,"examples":[{"fnId":232,"id":2,"exOrder":0}],"children":[]}]},{"id":234,"name":"STATS_BINOMIAL_TEST","description":"STATS_BINOMIAL_TEST(expr1, expr2, p, TWO_SIDED_PROB/EXACT_PROB/ONE_SIDED_OR_MORE/ONE_SIDED_PROB_OR_LESS) 형식으로 사용합니다.\nSTATS_BINOMIAL_TEST는 이분형 변수에 사용되는 정확한 확률 테스트로, 두 가지 가능한 값만 존재하는 경우에 사용됩니다. 이 함수는 표본 비율과 주어진 비율 간의 차이를 검정합니다. 이러한 검정에서는 일반적으로 표본 크기가 작습니다.\n이 함수는 네 개의 인수를 사용합니다: expr1은 조사 대상인 표본입니다. expr2는 비율이 예상되는 값들을 포함하며, p는 테스트할 비율입니다. 네 번째 인수는 VARCHAR2 유형의 반환 값입니다. 네 번째 인수를 생략하면 기본값인 TWO_SIDED_PROB이 사용됩니다.","itemType":"F","parentId":32,"examples":[{"fnId":234,"id":2,"query":"SELECT STATS_BINOMIAL_TEST(expr1, expr2, p) AS test_result FROM your_table;","exOrder":0}],"children":[]},{"id":235,"name":"STATS_CROSSTAB","description":"STATS_CROSSTAB(expr1, expr2, CHISQ_OBS/CHISQ_SIG/CHISQ_QF/CONT_COEFFICIENT/CRAMERS_V/PHI_COEFFICIENT/COHENS_K) 형식으로 사용합니다.\n교차표 (일반적으로 교차표라고 불립니다)는 두 개의 명목 변수를 분석하는 데 사용되는 방법입니다. STATS_CROSSTAB 함수는 세 개의 인수를 사용합니다: 두 개의 표현식과 VARCHAR2 유형의 반환 값입니다. expr1과 expr2는 분석되는 두 변수입니다. 이 함수는 세 번째 인수의 값에 따라 하나의 숫자를 반환합니다. 세 번째 인수를 생략하면 기본값인 CHISQ_SIG가 사용됩니다.","itemType":"F","parentId":32,"examples":[{"fnId":235,"id":2,"query":"SELECT STATS_CROSSTAB(expr1, expr2, \u0027CHISQ_SIG\u0027) AS crosstab_result FROM your_table;","exOrder":0}],"children":[]},{"id":236,"name":"STATS_F_TEST","description":"STATS_F_TEST(expr1, expr2, STATISTIC/DF_NUM/DF_DEN/ONE_SIDED_SIG/TWO_SIDED_SIG) 형식으로 사용합니다.\nSTATS_F_TEST 함수는 두 분산이 유의하게 다른지를 테스트합니다. 관찰된 F 값은 한 분산을 다른 분산으로 나눈 비율이므로, 1과 매우 다른 값은 일반적으로 유의한 차이를 나타냅니다.\n이 함수는 세 개의 인수를 사용합니다: expr1은 그룹화 또는 독립 변수이고, expr2는 값의 표본입니다. 함수는 세 번째 인수의 값에 따라 하나의 숫자를 반환합니다. 세 번째 인수를 생략하면 기본값인 TWO_SIDED_SIG가 사용됩니다.","itemType":"F","parentId":32,"examples":[{"fnId":236,"id":2,"query":"SELECT STATS_F_TEST(expr1, expr2, \u0027TWO_SIDED_SIG\u0027) AS f_test_result FROM your_table;","exOrder":0}],"children":[]},{"id":237,"name":"STATS_KS_TEST","description":"STATS_KS_TEST(expr1, expr2, STATISTIC/SIG) 형식으로 사용합니다.\nSTATS_KS_TEST는 두 개의 표본을 비교하여 동일한 모집단에서 가져온 것인지 또는 동일한 분포를 가진 모집단에서 가져온 것인지를 테스트하는 Kolmogorov-Smirnov 함수입니다. 이 함수는 표본이 가져온 모집단이 정규 분포를 따른다고 가정하지 않습니다.\n이 함수는 세 개의 인수를 사용합니다: 두 개의 표현식과 VARCHAR2 유형의 반환 값입니다. expr1은 데이터를 그룹으로 분류합니다. expr2는 각 그룹에 대한 값을 포함합니다. 함수는 세 번째 인수에 따라 하나의 값을 반환합니다. 세 번째 인수를 생략하면 기본값인 SIG가 사용됩니다.","itemType":"F","parentId":32,"examples":[{"fnId":237,"id":2,"query":"SELECT STATS_KS_TEST(expr1, expr2, \u0027SIG\u0027) AS ks_test_result FROM your_table;","exOrder":0}],"children":[]},{"id":238,"name":"STATS_MODE","description":"STATS_MODE(expr) 형식으로 사용합니다.\nSTATS_MODE 함수는 값 집합을 인수로 받고, 가장 빈도가 높게 발생하는 값이 반환됩니다. 여러 개의 모드가 존재하는 경우, Oracle Database는 하나를 선택하고 해당 값만 반환합니다.","itemType":"F","parentId":32,"examples":[{"fnId":238,"id":2,"exOrder":0}],"children":[]},{"id":239,"name":"STATS_MW_TEST","description":"STATS_MW_TEST(expr1, expr2, STATISTIC/U_STATISTIC/ONE_SIDED_SIG/TWO_SIDED_SIG) 형식으로 사용합니다.\nSTATS_MW_TEST 함수는 표본 간 차이가 STATS_T_TEST_* 함수처럼 정규 분포를 따른다고 가정하지 않습니다. 이 함수는 세 개의 인수와 VARCHAR2 유형의 반환 값이 필요합니다. expr1은 데이터를 그룹으로 분류합니다. expr2는 각 그룹의 값을 포함합니다. 함수는 세 번째 인수에 따라 하나의 값을 반환합니다. 세 번째 인수를 생략하면 기본값인 TWO_SIDED_SIG가 사용됩니다. ","itemType":"F","parentId":32,"examples":[{"fnId":239,"id":2,"query":"SELECT STATS_MW_TEST(expr1, expr2, \u0027TWO_SIDED_SIG\u0027) AS mw_test_result FROM your_table;","exOrder":0}],"children":[]},{"id":240,"name":"STATS_ONE_WAY_ANOVA","description":"STATS_ONE_WAY_ANOVA(expr1, expr2, SUM_SQUARES_BETEEN/SUM_SQUARES_WITHIN/DF_BETWEEN/DF_WITHIN/MEAN_SQUARES_BETWEEN/MEAN_SQUARES_WITHIN/F_RATIO/SIG) 형식으로 사용합니다.\n일원분산분석(One-way Analysis of Variance) 함수 (STATS_ONE_WAY_ANOVA)는 두 가지 다른 분산 추정치를 비교하여 그룹 또는 변수의 평균 차이를 통계적으로 유의한지 테스트합니다. 한 추정치는 각 그룹 또는 범주 내부의 분산에 기반합니다. 이를 그룹 내 평균제곱 또는 오차 제곱평균(mean squares within or mean square error)이라고 합니다. 다른 추정치는 그룹 평균 간 분산에 기반합니다. 이를 그룹 간 평균제곱(mean squares between)이라고 합니다. 그룹의 평균이 유의하게 다르다면, 그룹 간 평균제곱은 기대치보다 크고 그룹 내 평균제곱과 일치하지 않을 것입니다. 그룹의 평균이 일관되면, 두 분산 추정치는 대략 동일할 것입니다.\nSTATS_ONE_WAY_ANOVA 함수는 세 개의 인수와 VARCHAR2 유형의 반환 값이 필요합니다. expr1은 독립 또는 그룹 변수로 데이터를 여러 그룹으로 분할합니다. expr2는 각 그룹의 구성원에 해당하는 값이 있는 종속 변수(숫자 표현식)입니다. 함수는 세 번째 인수에 따라 하나의 값을 반환합니다. 세 번째 인수를 생략하면 기본값인 SIG가 사용됩니다.","itemType":"F","parentId":32,"examples":[{"fnId":240,"id":2,"query":"SELECT STATS_ONE_WAY_ANOVA(expr1, expr2, \u0027SIG\u0027) AS anova_result FROM your_table;","exOrder":0}],"children":[]},{"id":241,"name":"STATS_T_TEST_*","description":"STATS_T_TEST_ONE, STATS_T_TEST_PAIRED, STATS_T_TEST_INDEP, STATS_T_TEST_INDEPU 함수가 있습니다.\n함수(expr1, expr2, STATISTIC/DF/ONE_SIDED_SIG/TWO_SIDED_SIG) 형식으로 사용합니다.","itemType":"C","parentId":32,"children":[{"id":243,"name":"STATS_T_TEST_PAIRED","description":"두 표본, 쌍체 t-검정(또는 교차 t-검정)은 두 개의 관련된 표본 간에 평균의 차이가 통계적으로 유의한지를 검정하는 방법입니다.","itemType":"F","parentId":241,"examples":[{"fnId":243,"id":2,"query":"SELECT STATS_T_TEST_PAIRED(expr1, expr2, \u0027SIG\u0027) AS t_test_result FROM your_table;","exOrder":0}],"children":[]},{"id":242,"name":"STATS_T_TEST_ONE","description":"단일 표본 t-검정은 표본 평균이 주어진 값과 유의하게 다른지를 테스트하는 방법입니다.","itemType":"F","parentId":241,"examples":[{"fnId":242,"id":2,"query":"SELECT STATS_T_TEST_ONE(expr1, expr2, \u0027SIG\u0027) AS t_test_result FROM your_table;","exOrder":0}],"children":[]},{"id":244,"name":"STATS_T_TEST_INDEP","description":"동일한 분산을 가진 두 독립 그룹 간의 t-검정 (통합 분산)은 두 그룹의 평균 차이가 통계적으로 유의한지를 검정하는 방법입니다.","itemType":"F","parentId":241,"examples":[{"fnId":244,"id":2,"query":"SELECT STATS_T_TEST_INDEP(expr1, expr2, \u0027SIG\u0027) AS t_test_result FROM your_table;","exOrder":0}],"children":[]},{"id":245,"name":"STATS_T_TEST_INDEPU","description":"등분산을 가지지 않은 두 독립 그룹 간의 t-검정 (비등분산)은 두 그룹의 평균 차이가 통계적으로 유의한지를 검정하는 방법입니다.","itemType":"F","parentId":241,"examples":[{"fnId":245,"id":2,"query":"SELECT STATS_T_TEST_INDEPU(expr1, expr2, \u0027SIG\u0027) AS t_test_result FROM your_table;","exOrder":0}],"children":[]}]},{"id":246,"name":"STATS_WSR_TEST","description":"STATS_WSR_TEST(expr1, expr2, STATISTIC/ONE_SIDED_SIG/TWO_SIDED_SIG) 형식으로 사용합니다.\nSTATS_WSR_TEST는 짝을 이룬 표본들의 Wilcoxon Signed Ranks 검정으로, 표본들의 차이의 중앙값이 0과 유의하게 다른지를 판단하는 방법입니다. 차이의 절댓값을 정렬하고 순위를 할당합니다. 그런 다음 귀무가설은 양수 차이의 순위 합이 음수 차이의 순위 합과 같다는 것을 나타냅니다.\n이 함수는 세 개의 인수와 VARCHAR2 유형의 반환 값이 필요합니다. expr1은 짝을 이룬 표본을 나타내는 열이나 표현식입니다. expr2는 짝을 이룬 다른 표본을 나타내는 열이나 표현식입니다. 함수는 세 번째 인수에 따라 하나의 값을 반환합니다. 세 번째 인수를 생략하면 기본값인 SIG가 사용됩니다. 반환 값의 의미는 아래의 표에서 설명됩니다.","itemType":"F","parentId":32,"examples":[{"fnId":246,"id":2,"query":"SELECT STATS_WSR_TEST(expr1, expr2, \u0027SIG\u0027) AS wsr_test_result FROM your_table;","exOrder":0}],"children":[]},{"id":247,"name":"STDDEV","description":"STDDEV(DISTINCT/ALL expr) OVER(analytic_clause) 형식으로 사용합니다.\nSTDDEV 함수는 숫자 집합인 expr의 표본 표준 편차를 반환합니다. 이 함수는 집계 및 분석 함수로 사용할 수 있습니다. STDDEV_SAMP와 다른 점은 STDDEV는 입력 데이터가 1개의 행만 있는 경우에도 0을 반환하는 반면, STDDEV_SAMP는 null을 반환합니다.\nOracle 데이터베이스는 VARIANCE 집계 함수에 대해 정의된 분산의 제곱근으로 표준 편차를 계산합니다.\n이 함수는 숫자 유형 또는 숫자 유형으로 암묵적으로 변환될 수 있는 비숫자 유형을 인수로 사용합니다. 함수는 인수의 숫자 유형과 동일한 데이터 유형을 반환합니다.","itemType":"F","parentId":32,"examples":[{"fnId":247,"id":2,"query":"SELECT STDDEV(column_name) AS std_dev FROM your_table;","exOrder":0}],"children":[]},{"id":248,"name":"STDDEV_POP","description":"STDDEV_POP(expr) OVER(analytic_clause) 형식으로 사용합니다.\nSTDDEV_POP 함수는 모집단의 표준 편차를 계산하고 모집단 분산의 제곱근을 반환합니다. 이 함수는 집계 및 분석 함수로 사용할 수 있습니다.\n이 함수는 숫자 유형 또는 숫자 유형으로 암묵적으로 변환될 수 있는 비숫자 유형을 인수로 사용합니다. 함수는 인수의 숫자 유형과 동일한 데이터 유형을 반환합니다.","itemType":"F","parentId":32,"examples":[{"fnId":248,"id":2,"query":"SELECT STDDEV_POP(column_name) AS std_dev_pop FROM your_table;","exOrder":0}],"children":[]},{"id":250,"name":"SUM","description":"SUM(DISTINCT/ALL expr) OVER(analytic_clause) 형식으로 사용합니다.\nSUM 함수는 expr의 값들의 합을 반환합니다. 이 함수는 집계 함수 또는 분석 함수로 사용할 수 있습니다.\n이 함수는 숫자 유형 또는 숫자 유형으로 암묵적으로 변환될 수 있는 비숫자 유형을 인수로 사용합니다. 함수는 인수의 숫자 유형과 동일한 데이터 유형을 반환합니다.","itemType":"F","parentId":32,"examples":[{"fnId":250,"id":2,"query":"SELECT SUM(column_name) AS sum_value FROM your_table;","exOrder":0}],"children":[]},{"id":251,"name":"VAR_POP","description":"VAR_POP(expr) OVER(analytic_clause) 형식으로 사용합니다.\nVAR_POP 함수는 주어진 숫자 집합에서 null 값을 제외한 모집단 분산을 계산하여 반환합니다. 이 함수는 집계 및 분석 함수로 사용할 수 있습니다.\n이 함수는 숫자 유형 또는 숫자 유형으로 암묵적으로 변환될 수 있는 비숫자 유형을 인수로 사용합니다. 함수는 인수의 숫자 유형과 동일한 데이터 유형을 반환합니다.","itemType":"F","parentId":32,"examples":[{"fnId":251,"id":2,"query":"SELECT VAR_POP(column_name) AS var_pop_value FROM your_table;","exOrder":0}],"children":[]},{"id":252,"name":"VAR_SAMP","description":"VAR_SAMP(expr) OVER(analytic_clause) 형식으로 사용합니다.\nVAR_SAMP 함수는 주어진 숫자 집합에서 null 값을 제외한 표본 분산을 계산하여 반환합니다. 이 함수는 집계 및 분석 함수로 사용할 수 있습니다.\n이 함수는 숫자 유형 또는 숫자 유형으로 암묵적으로 변환될 수 있는 비숫자 유형을 인수로 사용합니다. 함수는 인수의 숫자 유형과 동일한 데이터 유형을 반환합니다.\n","itemType":"F","parentId":32,"examples":[{"fnId":252,"id":2,"query":"SELECT VAR_SAMP(column_name) AS var_samp_value FROM your_table;","exOrder":0}],"children":[]},{"id":253,"name":"VARIANCE","description":"\nSUM(DISTINCT/ALL expr) OVER(analytic_clause) 형식으로 사용합니다.\nVARIANCE 함수는 expr의 분산을 반환합니다. 이 함수는 집계 또는 분석 함수로 사용할 수 있습니다.\nOracle Database는 다음과 같이 expr의 분산을 계산합니다:\nexpr의 행 수 \u003d 1이면 0\nexpr의 행 수 \u003e 1이면 VAR_SAMP\nDISTINCT를 지정하는 경우, analytic_clause의 query_partition_clause만 지정할 수 있습니다. order_by_clause 및 windowing_clause는 허용되지 않습니다.\n이 함수는 숫자 유형 또는 숫자 유형으로 암묵적으로 변환될 수 있는 비숫자 유형을 인수로 사용합니다. 함수는 인수의 숫자 유형과 동일한 데이터 유형을 반환합니다.","itemType":"F","parentId":32,"examples":[{"fnId":253,"id":2,"query":"SELECT VARIANCE(column_name) AS variance_value FROM your_table;","exOrder":0}],"children":[]},{"id":214,"name":"GROUPING","description":"GROUPING(expr) 형식으로 사용합니다.\nGROUPING 함수는 일반적인 그룹화된 행과 슈퍼집계 행을 구분합니다. ROLLUP 및 CUBE와 같은 GROUP BY 확장 구문은 모든 값을 null로 나타내는 슈퍼집계 행을 생성합니다. GROUPING 함수를 사용하여 슈퍼집계 행에서 모든 값을 나타내는 null을 일반 행의 null과 구분할 수 있습니다.\n","itemType":"F","parentId":32,"examples":[{"fnId":214,"id":2,"query":"SELECT GROUPING(column1) AS is_superaggregate, SUM(column2) AS total_sum FROM your_table GROUP BY ROLLUP(column1);","exOrder":0}],"children":[]}]},{"id":33,"name":"분석 함수(Analytic Functions)","description":"분석 함수는 행 그룹을 기반으로 값을 계산합니다. 집계 함수와는 달리 각 그룹에 대해 여러 개의 행을 반환합니다. 행 그룹은 윈도우(window)라고 하며, 분석 절에 의해 정의됩니다.\n각 행애 대해 슬라이딩 윈도우가 정의되며, 현재 행에 대한 계산을 수행하기 위해 사용되는 행의 범위를 결정합니다. 윈도우 크기는 물리적인 행의 개수나 시간과 같은 논리적인 간격을 기반으로 할 수 있습니다.\n분석 함수는 쿼리에서 최종 ORDER BY 절을 제외한 마지막 단계로 수행됩니다. 분석 함수는 SELECT, ORDER BY 절에만 사용할 수 있습니다.","itemType":"C","parentId":9,"children":[{"id":258,"name":"NTILE","description":"NTILE(expr) OVER(query_partition_clause order_by_clause) 형식으로 사용합니다.\nNTILE은 분석 함수입니다. 이 함수는 expr로 지정한 수의 버킷으로 정렬된 데이터 집합을 나누고 각 행에 적절한 버킷 번호를 할당합니다. 버킷은 1부터 expr까지 번호가 매겨집니다. 각 파티션마다 expr 값은 양수 상수로 해결되어야 합니다. Oracle Database는 정수를 기대하며, expr이 정수 상수가 아닌 경우 Oracle은 값을 정수로 절사합니다. 반환 값은 NUMBER입니다.\n버킷에 포함된 행의 수는 최대 1까지 다를 수 있습니다. 나머지 값(행 수를 버킷으로 나눈 나머지)은 버킷 1부터 시작하여 각각 한 개씩 배정됩니다.\n만약 expr이 행 수보다 크다면, 행 수와 동일한 수의 버킷이 채워지고 나머지 버킷은 비어있을 것입니다.\nNTILE 또는 다른 분석 함수를 expr에 사용할 수 없습니다. 즉, 분석 함수를 중첩할 수 없지만, expr에는 다른 내장 함수 표현식을 사용할 수 있습니다.","itemType":"F","parentId":33,"examples":[{"fnId":258,"id":2,"query":"SELECT col1, col2, NTILE(4) OVER (ORDER BY col1) AS bucket_number FROM your_table;","exOrder":0}],"children":[]},{"id":254,"name":"FIRST_VALUE","description":"FIRST_VALUE(expr IGNORE NULLS) OVER(analytic_clause) 형식으로 사용합니다.\nFIRST_VALUE는 분석 함수입니다. 이 함수는 정렬된 값 집합에서 첫 번째 값을 반환합니다. 집합의 첫 번째 값이 null인 경우, IGNORE NULLS를 지정하지 않은 경우 함수는 NULL을 반환합니다. 이 설정은 데이터 밀도화에 유용합니다. IGNORE NULLS를 지정하면 FIRST_VALUE는 집합에서 첫 번째로 null이 아닌 값을 반환하며, 모든 값이 null인 경우에는 NULL을 반환합니다. 데이터 밀도화의 예제에 대해서는 \"Using Partitioned Outer Joins: Examples\"를 참조하십시오.\nFIRST_VALUE 또는 다른 분석 함수를 expr에 사용할 수 없습니다. 즉, 분석 함수를 중첩할 수 없지만, expr에는 다른 내장 함수 표현식을 사용할 수 있습니다. ","itemType":"F","parentId":33,"examples":[{"fnId":254,"id":2,"query":"SELECT col1, col2, FIRST_VALUE(col3) OVER (ORDER BY col1) AS first_val FROM your_table;","exOrder":0}],"children":[]},{"id":255,"name":"LAG","description":"LAG(value_expr, offset, default) OVER(query_partition_clause order_by_clause) 형식으로 사용합니다.\nLAG는 분석 함수입니다. 이 함수는 자체 조인 없이 한 번에 여러 행의 테이블에 액세스할 수 있도록 제공됩니다. 쿼리에서 반환된 일련의 행과 커서의 위치에 따라 LAG는 해당 위치 이전의 물리적 오프셋에 있는 행에 액세스할 수 있습니다.\noffset을 지정하지 않으면 기본값은 1입니다. 오프셋이 윈도우 범위를 벗어나면 선택적으로 지정한 기본값이 반환됩니다. default를 지정하지 않으면 기본값은 null입니다.\nvalue_expr에 LAG나 다른 분석 함수를 사용할 수 없습니다. 즉, 분석 함수를 중첩할 수 없지만 value_expr에는 다른 내장 함수 표현식을 사용할 수 있습니다.","itemType":"F","parentId":33,"examples":[{"fnId":255,"id":2,"query":"SELECT col1, col2, LAG(col2, 1, \u0027N/A\u0027) OVER (ORDER BY col1) AS lag_value FROM your_table;","exOrder":0}],"children":[]},{"id":256,"name":"LAST_VALUE","description":"LAST_VALUE(expr IGNORE NULLS) OVER(analytic_clause) 형식으로 사용합니다.\nLAST_VALUE는 분석 함수입니다. 이 함수는 정렬된 값 집합에서 마지막 값을 반환합니다. 값 집합의 마지막 값이 null인 경우, 함수는 IGNORE NULLS를 지정하지 않는 한 NULL을 반환합니다. 이 설정은 데이터 밀도화에 유용합니다. IGNORE NULLS를 지정하면 LAST_VALUE는 집합에서 첫 번째로 나타나는 비-null 값을 반환하거나 모든 값이 null인 경우 NULL을 반환합니다. 데이터 밀도화에 대한 예시는 \"Using Partitioned Outer Joins: Examples\"를 참조하십시오.\nexpr에는 LAST_VALUE나 다른 분석 함수를 사용할 수 없습니다. 즉, 분석 함수를 중첩할 수는 없지만, expr에는 다른 내장 함수 표현식을 사용할 수 있습니다. ","itemType":"F","parentId":33,"examples":[{"fnId":256,"id":2,"query":"SELECT col1, col2, LAST_VALUE(col2 IGNORE NULLS) OVER (ORDER BY col1) AS last_value FROM your_table;","exOrder":0}],"children":[]},{"id":257,"name":"LEAD","description":"LEAD(value_expr, offset, default) OVER(query_partition_clause order_by_clause) 형식으로 사용합니다.\nLEAD는 분석 함수입니다. 이 함수는 자체 조인 없이 동시에 테이블의 하나 이상의 행에 액세스할 수 있습니다. 질의 결과로 반환된 일련의 행과 커서 위치를 기준으로 LEAD는 해당 위치를 넘어서는 지정된 물리적 오프셋에 있는 행에 액세스합니다.\n만약 오프셋을 지정하지 않으면, 기본값은 1입니다. 옵션으로 지정한 기본값은 오프셋이 테이블 범위를 벗어날 경우 반환됩니다. 기본값을 지정하지 않으면 null이 기본값으로 사용됩니다.\nvalue_expr에는 LEAD나 다른 분석 함수를 사용할 수 없습니다. 즉, 분석 함수를 중첩할 수 없지만, value_expr에는 다른 내장 함수 표현식을 사용할 수 있습니다.","itemType":"F","parentId":33,"examples":[{"fnId":257,"id":2,"query":"SELECT col1, col2, LEAD(col2, 2, \u0027N/A\u0027) OVER (ORDER BY col1) AS lead_value FROM your_table;","exOrder":0}],"children":[]},{"id":259,"name":"RATIO_TO_REPORT","description":"RATIO_TO_REPORT(expr) OVER(query_partition_clause)\nRATIO_TO_REPORT은 분석 함수입니다. 이 함수는 값의 비율을 값 집합의 합에 대한 비율로 계산합니다. expr이 null로 평가되면, 비율을 보고하는 값도 null로 평가됩니다.\n값 집합은 query_partition_clause에 의해 결정됩니다. 이 절을 생략하면, 비율을 보고는 쿼리에서 반환된 모든 행을 대상으로 계산됩니다.\nRATIO_TO_REPORT 또는 다른 분석 함수를 expr에 사용할 수 없습니다. 즉, 분석 함수를 중첩할 수 없지만, expr에는 다른 내장 함수 표현식을 사용할 수 있습니다.","itemType":"F","parentId":33,"examples":[{"fnId":259,"id":2,"query":"SELECT col1, RATIO_TO_REPORT(col2) OVER (PARTITION BY col1) AS ratio FROM your_table;","exOrder":0}],"children":[]},{"id":260,"name":"ROW_NUMBER","description":"ROW_NUMBER(expr) OVER(query_partition_clause)\nROW_NUMBER는 분석 함수입니다. 이 함수는 적용된 각 행에 고유한 번호를 할당합니다. 번호는 order_by_clause에 지정된 순서로 행을 정렬한 후 1부터 시작합니다.\nROW_NUMBER를 사용하여 ROW_NUMBER 값을 검색하는 서브쿼리를 중첩하면, 내부 쿼리의 결과에서 정확한 하위 집합의 행을 찾을 수 있습니다. 이 함수의 사용을 통해 상위 N개, 하위 N개 및 특정 범위의 행을 보고할 수 있습니다. 일관된 결과를 위해 쿼리는 결정론적인 정렬 순서를 보장해야 합니다.\nROW_NUMBER나 다른 분석 함수를 expr에 사용할 수 없습니다. 즉, 분석 함수를 중첩할 수 없지만, expr에는 다른 내장 함수 표현식을 사용할 수 있습니다.","itemType":"F","parentId":33,"examples":[{"fnId":260,"id":2,"query":"SELECT col1, col2, ROW_NUMBER() OVER (ORDER BY col1) AS row_num FROM your_table;","exOrder":0}],"children":[]}]},{"id":30,"name":"컬렉션 함수(Collection Functions)","description":"컬럭션 함수는 중첩 테이블과 변수 배열에 대해 동작합니다.","itemType":"C","parentId":9,"children":[{"id":197,"name":"CARDINALITY","description":"CARDINALITY(nested_table) 형식으로 사용합니다.\nCARDINALITY 함수는 중첩 테이블의 요소 수를 반환합니다. 반환 형식은 NUMBER입니다. 중첩 테이블이 비어 있거나 null 컬렉션인 경우, CARDINALITY는 NULL을 반환합니다.\n","itemType":"F","parentId":30,"examples":[{"fnId":197,"id":2,"query":"SELECT CARDINALITY(nested_table_column) AS element_count FROM your_table WHERE condition;","exOrder":0}],"children":[]},{"id":198,"name":"COLLECT","description":"COLLECT(column) 형식으로 사용합니다.\nCOLLECT 함수는 인수로 모든 유형의 열을 사용하고 선택된 행에서 입력 유형의 중첩 테이블을 생성합니다. 이 함수의 결과를 얻으려면 CAST 함수 내에서 사용해야 합니다.\n만약 column 자체가 컬렉션인 경우, COLLECT의 출력은 컬렉션의 중첩 테이블입니다.\n","itemType":"F","parentId":30,"examples":[{"fnId":198,"id":2,"query":"SELECT CAST(COLLECT(column_name) AS nested_table_type) AS collected_data FROM your_table GROUP BY group_column;","exOrder":0}],"children":[]},{"id":199,"name":"POWERMULTISET","description":"POWERMULTISET(expr) 형식으로 사용합니다.\nPOWERMULTISET 함수는 중첩 테이블을 입력으로 받고, 입력 중첩 테이블의 모든 비어 있지 않은 하위 집합 (서브멀티셋이라고 함)을 포함하는 중첩 테이블의 중첩 테이블을 반환합니다.\n","itemType":"F","parentId":30,"examples":[{"fnId":199,"id":2,"query":"SELECT POWERMULTISET(CAST(COLLECT(column_name) AS nested_table_type)) AS submultisets FROM your_table GROUP BY group_column;","exOrder":0}],"children":[]},{"id":200,"name":"POWERMULTISET_BY_CARDINALITY","description":"POWERMULTISET_BY_CARDINALITY(expr, cardinality) 형식으로 사용합니다.\nPOWERMULTISET_BY_CARDINALITY 함수는 중첩 테이블과 기수(cardinality)를 입력으로 받고, 지정된 기수의 중첩 테이블에 포함된 모든 비어 있지 않은 하위 집합(서브멀티셋)을 포함하는 중첩 테이블의 중첩 테이블을 반환합니다.\n","itemType":"F","parentId":30,"examples":[{"fnId":200,"id":2,"query":"SELECT POWERMULTISET_BY_CARDINALITY(CAST(COLLECT(column_name) AS nested_table_type), specified_cardinality) AS submultisets FROM your_table GROUP BY group_column;","exOrder":0}],"children":[]},{"id":201,"name":"SET","description":"SET(nested_table) 형식으로 사용합니다.\nSET 함수는 중첩 테이블을 중복을 제거하여 집합으로 변환합니다. 이 함수는 서로 다른 요소로 이루어진 중첩 테이블을 반환합니다. 반환된 중첩 테이블은 입력 중첩 테이블과 동일한 유형입니다.\n중첩 테이블의 요소 유형은 비교 가능해야 합니다.\n","itemType":"F","parentId":30,"examples":[{"fnId":201,"id":2,"query":"SELECT SET(CAST(COLLECT(column_name) AS nested_table_type)) AS distinct_elements FROM your_table GROUP BY group_column;","exOrder":0}],"children":[]}]}]}]}